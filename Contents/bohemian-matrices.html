
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bounded Height Matrices of Integers (Bohemian Matrices) &#8212; Computational Discovery on Jupyter</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script>
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="shortcut icon" href="../_static/logo.jpg"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Mandelbrot Polynomials and Matrices" href="mandelbrot.html" />
    <link rel="prev" title="Fractals and Julia Sets" href="fractals-and-julia-sets.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.jpg" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Computational Discovery on Jupyter</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../index.html">
   Welcome to Computational Discovery on Jupyter
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Preface
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../preamble.html">
   Preamble
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Contents
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="continued-fractions.html">
   Continued Fractions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="rootfinding.html">
   Rootfinding, Newton’s Method, and Dynamical Systems
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="fractals-and-julia-sets.html">
   Fractals and Julia Sets
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Bounded Height Matrices of Integers (Bohemian Matrices)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mandelbrot.html">
   Mandelbrot Polynomials and Matrices
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="chaos-game-representation.html">
   Chaos Game Representation
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Appendix
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../Appendix/floating-point.html">
   The Bare Minimum about Floating-Point
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Appendix/binomials-factorials-combinatorics.html">
   Binomials, Factorials, and other Combinatorial Things
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Appendix/complex-numbers.html">
   Complex Numbers
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Appendix/symbolic-computation.html">
   Symbolic Computation: The Pitfalls
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Solutions
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../Solutions/Solutions%20to%20Continued%20Fraction%20Exercises.html">
   Solutions to Continued Fractions Exercises
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Solutions/Solutions%20to%20the%20Rootfinding%20Chapter%20Exercises.html">
   Solutions to the Rootfinding Chapter Exercises
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Solutions/Solutions%20to%20the%20Julia%20Set%20Exercises.html">
   Solutions to the Julia Set Exercises
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Solutions/Solutions%20to%20Exercises%20%28not%20Activities%29%20in%20the%20Bohemian%20Unit.html">
   Solutions to Exercises (not Activities) in the Bohemian Unit
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Solutions/Solutions%20to%20Mandelbrot%20Exercises.html">
   Solutions to Mandelbrot Polynomials and Matrices Exercises
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Back Matter
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../acknowledgements.html">
   Acknowledgements
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../about.html">
   About the authors
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../references.html">
   References
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/Contents/bohemian-matrices.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/Computational-Discovery-on-Jupyter/Computational-Discovery-on-Jupyter"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        
        <a class="edit-button" href="https://github.com/Computational-Discovery-on-Jupyter/Computational-Discovery-on-Jupyter/edit/master/book/Contents/bohemian-matrices.ipynb"><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Edit this page"><i class="fas fa-pencil-alt"></i>suggest edit</button></a>
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-note-on-programming-style-for-this-notebook">
   A note on programming style for this notebook
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#choosing-at-random-instead-of-exhausting-all-possiblities">
     Choosing at “random” instead of exhausting all possiblities
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#back-to-the-math-a-lightning-introduction-to-matrices">
   Back to the math: A lightning introduction to matrices
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#table-of-results">
     Table of results
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#eigenvalues">
   Eigenvalues
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#a-useful-theorem-the-gerschgorin-circle-theorem">
     A useful theorem: the Gerschgorin Circle Theorem
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#formal-statement">
       Formal statement
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#eigenvalues-of-the-bohemian-upper-hessenberg-toeplitz-family">
     Eigenvalues of the Bohemian Upper Hessenberg Toeplitz family.
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#bohemian-matrices-population-and-structure">
   Bohemian Matrices: Population and Structure
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#a-general-family-dense-or-full-matrices">
     A. General family (“dense” or “full” matrices)
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#b-symmetric-family">
     B. Symmetric family
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#number-of-distinct-characteristic-polynomials-for-symmetric-bohemians-with-various-populations">
       Number of distinct characteristic polynomials for symmetric Bohemians with various populations
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#c-skew-symmetric-matrices">
     C. Skew-symmetric matrices
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#d-toeplitz-matrices-hankel-matrices">
     D. Toeplitz matrices, Hankel matrices
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#e-circulant-matrices">
     E. Circulant matrices
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#f-trididagonal-and-other-banded-matrices">
     F. Trididagonal and other banded matrices
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#g-upper-hessenberg-matrices">
     G. Upper Hessenberg matrices
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#an-upgrade-of-gerschgorin-s-theorem-for-unit-upper-hessenberg-matrices">
       An upgrade of Gerschgorin’s Theorem for unit upper Hessenberg matrices.
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#h-frobenius-companion-matrices">
     H. Frobenius companion matrices
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#i-generalized-companion-matrices">
     I. Generalized companion matrices
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#j-anti-tridiagonal-matrices-and-anti-banded-matrices">
     J. Anti-tridiagonal matrices and anti-banded matrices
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#k-generalized-bohemian-eigenvalues">
     K. Generalized Bohemian eigenvalues
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#l-polynomial-eigenvalues-in-bohemia">
     L. Polynomial eigenvalues in Bohemia
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#m-higher-dimensions">
     M. Higher dimensions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#n-doubly-companion-matrices">
     N. Doubly companion matrices
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#o-other">
     O. Other
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#choice-of-colours-and-colourizing-the-density-plots">
   Choice of colours, and colourizing the density plots
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#discussion-topics">
   Discussion topics
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-influence-of-population">
     The influence of population
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#applications">
   Applications
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercises-for-the-bohemian-matrix-unit">
   Exercises for the Bohemian Matrix Unit
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Bounded Height Matrices of Integers (Bohemian Matrices)</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-note-on-programming-style-for-this-notebook">
   A note on programming style for this notebook
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#choosing-at-random-instead-of-exhausting-all-possiblities">
     Choosing at “random” instead of exhausting all possiblities
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#back-to-the-math-a-lightning-introduction-to-matrices">
   Back to the math: A lightning introduction to matrices
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#table-of-results">
     Table of results
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#eigenvalues">
   Eigenvalues
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#a-useful-theorem-the-gerschgorin-circle-theorem">
     A useful theorem: the Gerschgorin Circle Theorem
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#formal-statement">
       Formal statement
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#eigenvalues-of-the-bohemian-upper-hessenberg-toeplitz-family">
     Eigenvalues of the Bohemian Upper Hessenberg Toeplitz family.
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#bohemian-matrices-population-and-structure">
   Bohemian Matrices: Population and Structure
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#a-general-family-dense-or-full-matrices">
     A. General family (“dense” or “full” matrices)
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#b-symmetric-family">
     B. Symmetric family
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#number-of-distinct-characteristic-polynomials-for-symmetric-bohemians-with-various-populations">
       Number of distinct characteristic polynomials for symmetric Bohemians with various populations
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#c-skew-symmetric-matrices">
     C. Skew-symmetric matrices
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#d-toeplitz-matrices-hankel-matrices">
     D. Toeplitz matrices, Hankel matrices
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#e-circulant-matrices">
     E. Circulant matrices
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#f-trididagonal-and-other-banded-matrices">
     F. Trididagonal and other banded matrices
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#g-upper-hessenberg-matrices">
     G. Upper Hessenberg matrices
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#an-upgrade-of-gerschgorin-s-theorem-for-unit-upper-hessenberg-matrices">
       An upgrade of Gerschgorin’s Theorem for unit upper Hessenberg matrices.
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#h-frobenius-companion-matrices">
     H. Frobenius companion matrices
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#i-generalized-companion-matrices">
     I. Generalized companion matrices
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#j-anti-tridiagonal-matrices-and-anti-banded-matrices">
     J. Anti-tridiagonal matrices and anti-banded matrices
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#k-generalized-bohemian-eigenvalues">
     K. Generalized Bohemian eigenvalues
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#l-polynomial-eigenvalues-in-bohemia">
     L. Polynomial eigenvalues in Bohemia
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#m-higher-dimensions">
     M. Higher dimensions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#n-doubly-companion-matrices">
     N. Doubly companion matrices
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#o-other">
     O. Other
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#choice-of-colours-and-colourizing-the-density-plots">
   Choice of colours, and colourizing the density plots
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#discussion-topics">
   Discussion topics
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-influence-of-population">
     The influence of population
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#applications">
   Applications
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercises-for-the-bohemian-matrix-unit">
   Exercises for the Bohemian Matrix Unit
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="bounded-height-matrices-of-integers-bohemian-matrices">
<h1>Bounded Height Matrices of Integers (Bohemian Matrices)<a class="headerlink" href="#bounded-height-matrices-of-integers-bohemian-matrices" title="Permalink to this headline">¶</a></h1>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{bmatrix}
-1 &amp; \phantom{-}0 &amp; \phantom{-}1 &amp; \phantom{-}1 \\
\phantom{-}1  &amp; \phantom{-}1 &amp; -1 &amp; \phantom{-}0 \\
\phantom{-}0 &amp; \phantom{-}0 &amp; \phantom{-}1 &amp; -1 \\
-1 &amp; -1 &amp; -1 &amp; \phantom{-}1 
\end{bmatrix}
\end{split}\]</div>
<p>Matrices have a central place in modern computation, and are often introduced in high school. This unit does not presuppose knowledge of matrices, however, or try to teach the standard curriculum. Instead, we travel quickly to a new place in the linear algebra lanscape (we might as well call it Bohemia, for <strong>BO</strong>unded <strong>HE</strong>ight <strong>M</strong>atrices of <strong>I</strong>ntegers (BOHEMI))  and turn you loose to explore on your own. As we write this unit, there is not a lot known about this area, and you may very well discover something new, for yourself. We’re not kidding.</p>
<p>But many people are now interested, and the field is changing pretty rapidly.  Instead of worrying about that, or about missing opportunities, we will concentrate on the fun parts.</p>
<p>As motivation, we point at the pictures you can find at <strong><a class="reference external" href="http://www.bohemianmatrices.com/gallery/">bohemianmatrices.com/gallery</a></strong>.  We will explain here how to create your own.</p>
<p>The introduction to matrices in section <a class="reference external" href="#a-lightning-introduction-to-matrices">2</a> is short, and even if you know matrices <em>well</em>, we suggest you read it, for notation as well as a refresher on some more obscure notions! Besides, there’s some open questions in there already.</p>
<p><strong>A Note to the Student/Reader</strong> If you have not yet had an introduction to matrices, our “Lightning Introduction” below will get you <em>started</em> enough to get something out of this section (really) and may also be enough to allow you to make an original contribution (really! Chiefly because you won’t be encumbered with the standard points of view). But it will not replace a Linear Algebra course.  We recommend that you just plunge in, and try and make sense of this right away (you might have to read the introduction to complex numbers in the appendix, but that’s fairly short).  We also recommend that later, after you have had a linear algebra course, you come back and read/do the activities again, because you might (probably will) get more out of it the second time.  We <em>expect</em> that doing things in this order will enrich your linear algebra course.  In particular, we think a lot of linear algebra courses don’t pay enough attention to <em>eigenvalues</em> (defined below, don’t you worry!); this should fix that problem.  Also, the beginning student doesn’t see enough of the different possible matrix structures (symmetric, skew-symmetric, tridiagonal, and so on, again defined below) and so the experience here of <em>making your own</em> structures will help with that as well.</p>
<p><strong>A Note to the Instructor</strong> The “Lightning Introduction to Matrices” below starts with motivating the determinant, and also matrix-vector notation and multiplication conventions, which are often glossed over in a first treatment.  Although they are very simple notions (to people who find linear algebra simple, and to people who have had a lot of practice with it) these first notions sometimes cause trouble, and that’s one reason we include them here explicitly.  Our “Lightning Introduction” does <em>not</em> cover much standard material from linear algebra, though, and that is intentional: we don’t want to replace the linear algebra courses so much as enrich them and strengthen them.  We don’t even mention Laplace expansion or Gaussian Elimination or LU factoring or, well, much of anything that is in any standard course.  That standard material <em>might</em> be helpful for the student/learner here (we think it’s useful to know, for instance, that symmetric matrices with real entries have only real eigenvalues; or that complex symmetric matrices are not Hermitian matrices) but the volume of “Linear Algebra Facts” is so overwhelmingly large that the student might spend all their time trying to memorize them (for instance, the distinction between “defective” matrices versus “derogatory” matrices—a distinction that we ourselves have to look up all the time).  We don’t want to throw the student into the deep end of what is already <em>known</em>.  Instead we want to throw them into the (deeper!) end of what is <em>unknown</em>!  We have found that beginning students have exceptional creativity, and we want to use that.  So we introduce matrices in a “minimal” kind of way, in the hopes that the students will find new paths for themselves.</p>
<p>One important aspect of genuine learning, though, is to make connections to what people already know; so if the student <em>does</em> know some linear algebra facts, they will for sure feel more comfortable in this section.  We just think that the student can do very well even if they <em>don’t</em> feel comfortable (just yet).</p>
<div class="section" id="a-note-on-programming-style-for-this-notebook">
<h2>A note on programming style for this notebook<a class="headerlink" href="#a-note-on-programming-style-for-this-notebook" title="Permalink to this headline">¶</a></h2>
<p>We will introduce various Python imports as we go along.  Some of the code that we will show is very definitely intended to be read and understood, rather than blindly run.  We intend our code more to be a guide for what to do, and it’s written for ease of understanding, not for efficiency.  If you want to take this code and make it faster and better, please go ahead!  Alternatively, writing your own from scratch might be both easier and more fun.  We leave it up to you.</p>
<p>Here are the packages we are going to need (we import them now because why not):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.polynomial</span> <span class="kn">import</span> <span class="n">Polynomial</span> <span class="k">as</span> <span class="n">Poly</span>
<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">ast</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;../../code&#39;</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">bohemian_inheritance</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">densityPlot</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
</div>
</div>
<p>The programs get gradually more intricate as the notebook goes along, but none of the codes are <em>very</em> long.  We’ll try to explain what we are doing, as we go.</p>
<p>The Maple packages that we use in our Maple code (in the parallel Maple documents) are (perhaps not surprisingly) very similar:</p>
<ol class="simple">
<li><p>Iterator</p></li>
<li><p>RandomTools</p></li>
<li><p>evalhf (for hardware-float evaluation: fast and finicky)</p></li>
<li><p>plots</p></li>
<li><p>Our own code BohemianUtilities.mpl, which is usually attached to Maple workbooks</p></li>
<li><p>CodeTools:-Usage</p></li>
<li><p>read/write (built-in to basic Maple)</p></li>
<li><p>math functions are built-in to basic Maple</p></li>
<li><p>ImageTools</p></li>
</ol>
<p>We have also decided to sprinkle the activities (including some of what we formerly called exercises) throughout the notebook.</p>
<p>Before we begin the math of linear algebra, though, let’s look at some computer tools that will be useful.  First, we will need a way to write down <em>all possible</em> vectors of length 3 (or whatever), whose entries are from a given (finite) population.  We now show how to use the <em>itertools</em> package to do this.  We will need this ability in what follows.  We will also need to be able to sample randomly from such collections, but it will turn out to be easier to manage such sampling with our own code, which you can use for your own explorations.</p>
<p>The first Python package we imported was “itertools”.  These are tools for iterating over various combinatorial structures.  We are only going to need the simplest structure, called a <a class="reference external" href="https://en.wikipedia.org/wiki/Cartesian_product">Cartesian Product</a>.  Look over the following code, which is intended to generate all possible sequences of length “sequencelength” where each entry of the sequence can be any one of the given “population”.  Below, we show two methods of iterating through the possibilities.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">population</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">1</span><span class="n">j</span><span class="p">]</span> <span class="c1"># Choose a finite set of complex numbers (usually integers)</span>
<span class="n">sequencelength</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1"># We will work with sequences of length &quot;sequencelength&quot;</span>
<span class="n">numberpossible</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">)</span><span class="o">**</span><span class="n">sequencelength</span>  <span class="c1"># Each entry of the sequence is one of the population</span>
<span class="c1"># Generate (one at a time) all possible choices for</span>
<span class="c1"># vector elements: this is what itertools.product does for us.</span>
<span class="n">possibilities</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span> <span class="n">population</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="n">sequencelength</span> <span class="p">)</span>
<span class="n">possible</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">possibilities</span><span class="p">)</span>
<span class="c1"># Enumerate all lists of possible population choices:</span>
<span class="c1"># Gets the next one when needed.</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">numberpossible</span> <span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">possible</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sequencelength</span><span class="p">)]</span> <span class="p">)</span>

<span class="c1"># Another way: (creates an actual big list)</span>
<span class="n">possibilities</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="n">sequencelength</span><span class="p">))</span>

<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">possibilities</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sequencelength</span><span class="p">)])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0 [1.0, 1.0, 1.0]
1 [1.0, 1.0, 1j]
2 [1.0, 1j, 1.0]
3 [1.0, 1j, 1j]
4 [1j, 1.0, 1.0]
5 [1j, 1.0, 1j]
6 [1j, 1j, 1.0]
7 [1j, 1j, 1j]
[1.0, 1.0, 1.0]
[1.0, 1.0, 1j]
[1.0, 1j, 1.0]
[1.0, 1j, 1j]
[1j, 1.0, 1.0]
[1j, 1.0, 1j]
[1j, 1j, 1.0]
[1j, 1j, 1j]
</pre></div>
</div>
</div>
</div>
<p>By changing the variable <code class="docutils literal notranslate"><span class="pre">sequencelength</span></code> above, we can generate all possible vectors of whatever length we want; this is the “Cartesian Product” of sequencelength copies of the population.  The number of such vectors grows exponentially with sequencelength (and later we will see that sequencelength itself can grow like the square of the dimension of the matrix—this is very, very fast growth indeed, and leaves simple exponential growth (and even factorial growth!) in the <em>dust</em>).</p>
<div class="section" id="choosing-at-random-instead-of-exhausting-all-possiblities">
<h3>Choosing at “random” instead of exhausting all possiblities<a class="headerlink" href="#choosing-at-random-instead-of-exhausting-all-possiblities" title="Permalink to this headline">¶</a></h3>
<p>Sometimes we will want only to sample the population (because the total number of possibilities is too big).  To do that, we at first thought to start with an integer “chosen at random” from <span class="math notranslate nohighlight">\(0\)</span> to the largest possible number (<code class="docutils literal notranslate"><span class="pre">numberpossible</span></code> above, minus 1 of course because Python).  Then we needed to convert that integer into its base-<span class="math notranslate nohighlight">\(b\)</span> representation, where <span class="math notranslate nohighlight">\(b\)</span> is the size of the population.  Then each base-<span class="math notranslate nohighlight">\(b\)</span> digit would give us a unique member of the population.</p>
<p>We did this for a while, before realizing that it was silly.  The conversion to a base-<span class="math notranslate nohighlight">\(b\)</span> representation gave us a vector of random numbers; the vector was of length “sequencelength” and the random numbers were in range(len(population)).  Why not simply create that vector in the first place?  So that is what we now do.</p>
</div>
</div>
<div class="section" id="back-to-the-math-a-lightning-introduction-to-matrices">
<span id="sec-a-lightning-introduction-to-matrices"></span><h2>Back to the math: A lightning introduction to matrices<a class="headerlink" href="#back-to-the-math-a-lightning-introduction-to-matrices" title="Permalink to this headline">¶</a></h2>
<p>Suppose each of the numbers <span class="math notranslate nohighlight">\(t_1\)</span> and <span class="math notranslate nohighlight">\(t_{2}\)</span> might be <span class="math notranslate nohighlight">\(-1\)</span>, <span class="math notranslate nohighlight">\(0\)</span>, or <span class="math notranslate nohighlight">\(1\)</span>, maybe <span class="math notranslate nohighlight">\((-1, 1)\)</span> or <span class="math notranslate nohighlight">\((1, 0)\)</span>, any of the nine choices. Then suppose also that we have the following two equations in two unknowns <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> to solve</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
    t_{1}x + t_{2}y &amp;= 1 \\
    -x + t_{1}y &amp;= -1
\end{align*}\]</div>
<p>Notice that <span class="math notranslate nohighlight">\(t_{1}\)</span> occurs in both equations. This is a rather special system. To solve these, it seems very easy to multiply the second equation by <span class="math notranslate nohighlight">\(t_{1}\)</span> to get</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    -t_{1}x + t_{1}^{2}y = -t_{1} \&gt;.
\end{equation*}\]</div>
<p>We can add this equation to the first, which cancels the <span class="math notranslate nohighlight">\(x\)</span> term, to get</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    0\cdot x + (t_{2} + t_{1}^{2})y = 1 - t_{1} \&gt;.
\end{equation*}\]</div>
<p>Provided <span class="math notranslate nohighlight">\(t_{2} + t_{1}^{2}\)</span> is not equal to zero, we can find <span class="math notranslate nohighlight">\(y\)</span>:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    y = \dfrac{1 - t_{1}}{t_{2} + t_{1}^{2}} \quad \text{if}\ t_{2} + t_{1}^{2} \neq 0 \&gt;.
\end{equation*}\]</div>
<p>If <span class="math notranslate nohighlight">\(t_{2} + t_{1}^{2} = 0\)</span> and we’re “unlucky” in that <span class="math notranslate nohighlight">\(1 - t_{1} \neq 0\)</span> then <span class="math notranslate nohighlight">\(0\cdot y\)</span> is nonzero, which is impossible. If we’re “lucky” and <span class="math notranslate nohighlight">\(t_{1} = 1,\)</span> then <span class="math notranslate nohighlight">\(y\)</span> can be anything and still <span class="math notranslate nohighlight">\(0\cdot y = 0\)</span>. Once we have <span class="math notranslate nohighlight">\(y\)</span>, the second equation gives <span class="math notranslate nohighlight">\(x\)</span> handily.</p>
<p>But to avoid relying on luck we’d like <span class="math notranslate nohighlight">\(t_{2} + t_{1}^{2} \neq 0\)</span>. <strong>We say that the system is “singular” if this quantity is zero.</strong></p>
<p>Increase the dimension of our system to the following, analogous, set of three equations in three unknowns <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>, and <span class="math notranslate nohighlight">\(z\)</span>:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{alignat*}{8}
    t_{1}x &amp; &amp;+ t_{2}y &amp; &amp;+ t_{3}z &amp; &amp; &amp;= 1\\
    -x &amp; &amp;+ t_{1}y &amp; &amp;+ t_{2}z &amp; &amp; &amp;= 0 \\
    &amp; &amp; -y &amp; &amp;+ t_{1}z &amp; &amp; &amp;=-1 \&gt;.
\end{alignat*}\]</div>
<p>Notice that there’s only one more number, <span class="math notranslate nohighlight">\(t_{3} \in \{-1, 0, 1\}\)</span>. Again this is a special system.</p>
<p>To solve it, multiply the second equation by <span class="math notranslate nohighlight">\(t_{1}\)</span> and add it to the first to get</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    0\cdot x + (t_{2} + t_{1}^{2})y + (t_{3} + t_{2}t_{1})z = 1 \&gt;.
\end{equation*}\]</div>
<p>Now multiply the third equation by <span class="math notranslate nohighlight">\(t_{2} + t_{1}^{2}\)</span> and add it to this one:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    (t_{3} + 2t_{2}t_{1} + t_{1}^{3})z = 1 - (t_{2} + t_{1}^{2}) \&gt;. 
\end{equation*}\]</div>
<p>Again, what determines if we can solve for <span class="math notranslate nohighlight">\(z\)</span> or not is whether or not</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    t_{3} + 2t_{2}t_{1} + t_{1}^{3} = 0 \&gt;.
\end{equation*}\]</div>
<p>We’ll join common usage and call this the “determinant” of our equations. <strong>If the determinant is zero, we say that the system is singular.</strong> (Curiously enough, the theory of determinants preceded the theory of matrices, in its history. That’s why we’re doing it this way now. It’s easier.)</p>
<p>The following four-dimensional system is likewise analogous:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{alignat*}{10}
    t_{1}x &amp; &amp;+ t_{2}y &amp; &amp;+ t_{3}z &amp; &amp;+ t_{4}w &amp; &amp; &amp;= 1 \\
    -x &amp; &amp;+ t_{1}y &amp; &amp;+ t_{2}z &amp; &amp;+ t_{3}w &amp; &amp; &amp;=0 \\
    &amp; &amp;-y &amp; &amp;+ t_{1}z &amp; &amp;+ t_{2}w &amp; &amp; &amp;=0 \\
    &amp; &amp; &amp; &amp;-z &amp; &amp;+ t_{1}w &amp; &amp; &amp;= -1 \&gt;.
\end{alignat*}\]</div>
<p>It begins to be tiring to write and read <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>, <span class="math notranslate nohighlight">\(z\)</span>, <span class="math notranslate nohighlight">\(w\)</span> over and over. We make use of the following <em>convention</em></p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    \begin{bmatrix}
        t_{1} &amp; t_{2} &amp; t_{3} &amp; t_{4}
    \end{bmatrix}
    \begin{bmatrix}
        x \\
        y \\
        z \\
        w
    \end{bmatrix}
\end{equation*}\]</div>
<p>meaning <span class="math notranslate nohighlight">\(t_{1}x + t_{2}y + t_{3}z + t_{4}w\)</span>. This hardly seems useful, until we add the further convention that we can do several equation at once, like so:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    \begin{bmatrix}
        t_{1} &amp; t_{2} &amp; t_{3} &amp; t_{4} \\
        -1 &amp; t_{1} &amp; t_{2} &amp; t_{3} \\
        &amp; -1 &amp; t_{1} &amp; t_{2} \\
        &amp; &amp; -1 &amp; t_{1}
    \end{bmatrix}
    \begin{bmatrix}
        x \\
        y \\
        z \\
        w \\
    \end{bmatrix}=
    \begin{bmatrix}
        1 \\
        0 \\
        0 \\
        -1
    \end{bmatrix}
    \&gt;.
\end{equation*}\]</div>
<p>This array on the left is of course a <em>matrix</em>, where we have further used the convention of leaving blank the entries where zeros are (which requires a neat hand when writing on paper or a board).  This gives us an <em>algebra</em> of matrices, when we extend this product notion columnwise: writing the matrix <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> as a collection of columns <span class="math notranslate nohighlight">\([\mathbf{b}_1, \mathbf{b}_2, \ldots, \mathbf{b}_m]\)</span> we then define the product of two matrices <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> as <span class="math notranslate nohighlight">\(\mathbf{A}\mathbf{B} = [\mathbf{A}\mathbf{b}_1, \mathbf{A}\mathbf{b}_2, \ldots, \mathbf{A}\mathbf{b}_m]\)</span>; that is, each column of the product is the column that you get by multiplying <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> times that column of <span class="math notranslate nohighlight">\(\mathbf{B}\)</span>.  By trying a few examples, you can convince yourself that usually this multiplication is <em>not</em> commutative: most of the time, <span class="math notranslate nohighlight">\(\mathbf{A}\mathbf{B}\)</span> is not the same as <span class="math notranslate nohighlight">\(\mathbf{B}\mathbf{A}\)</span>.  Sometimes it is, though, and when it is, something special happens, which we will talk about later.</p>
<p>The diagonal of the matrix with all the <span class="math notranslate nohighlight">\(t_{1}\)</span>’s is called the <em>main</em> diagonal; the one with all the <span class="math notranslate nohighlight">\(-1\)</span>’s is called the <span class="math notranslate nohighlight">\(1^{\text{st}}\)</span> <em>subdiagonal</em>. Because this matrix is constant on each of its diagonals, it’s called a “Toeplitz” matrix (after <a class="reference external" href="https://en.wikipedia.org/wiki/Otto_Toeplitz">Otto Toeplitz</a>). Because all entries are zero below the <span class="math notranslate nohighlight">\(1^{\text{st}}\)</span> subdiagonal, it’s called an upper Hessenberg matrix (after <a class="reference external" href="https://en.wikipedia.org/wiki/Karl_Hessenberg">Karl Hessenberg</a>). This matrix is indeed <em>both</em> Toeplitz and upper Hessenberg. Because each <span class="math notranslate nohighlight">\(t_{i}\)</span> (and the subdiagonal entries) is either <span class="math notranslate nohighlight">\(-1\)</span>, <span class="math notranslate nohighlight">\(0\)</span>, or <span class="math notranslate nohighlight">\(1\)</span>, the matrix is also Bohemian. We say this is a Bohemain upper Hessenberg Toeplitz matrix.</p>
<p>In matrix form, the <span class="math notranslate nohighlight">\(1\times 1\)</span> equation <span class="math notranslate nohighlight">\(t_{1}x = 1\)</span> is pretty boring, but this gives us the following sequence of matrices:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{alignat*}{3}
    &amp;\begin{bmatrix}
        t_{1}
    \end{bmatrix}
    &amp;&amp;\quad \text{with determinant $t_{1}$} \\
    &amp;\begin{bmatrix}
        t_{1} &amp; t_{2} \\
        -1 &amp; t_{1}
    \end{bmatrix}
    &amp;&amp;\quad \text{with determinant $t_{2}+ t_{1}^{2}$} \\
    &amp;\begin{bmatrix}
        t_{1} &amp; t_{2} &amp; t_{3} \\
        -1 &amp; t_{1} &amp; t_{2} \\
        &amp; -1 &amp; t_{1}
    \end{bmatrix}
    &amp; &amp;\quad \text{with determinant $t_{3} + 2t_{2}t_{1} + t_{1}^{3}$}
\end{alignat*}\]</div>
<p>and now</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    \begin{bmatrix}
        t_{1} &amp; t_{2} &amp; t_{3} &amp; t_{4} \\
        -1 &amp; t_{1} &amp; t_{2} &amp; t_{3} \\
        &amp; -1 &amp; t_{1} &amp; t_{2} \\
        &amp; &amp; -1 &amp; t_{1}
    \end{bmatrix}\&gt;.
\end{equation*}\]</div>
<p>We claim this four by four system has determinant</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    t_{4} + 3t_{2}t_{1}^{2} + 2t_{3}t_{1} + t_{2}^{2} + t_{1}^{4} \&gt;.
\end{equation*}\]</div>
<p>By the method we’ve demonstrated (or, if you already know how to take determinants) you should be able to verify that.</p>
<p><strong>First Activity:</strong> Guess the pattern, and give a way to compute the <span class="math notranslate nohighlight">\(5\times 5\)</span> and <span class="math notranslate nohighlight">\(6 \times 6\)</span> version. (Hint: Yes, it’s in Wikipedia, but unless you know under which name, this doesn’t help.)</p>
<p><strong>Second Activity:</strong> How many matrices of this kind are there at each dimension (This is easy.) <em>How many matrices of this kind have zero determinant?</em> For instance, the <span class="math notranslate nohighlight">\(1 \times 1\)</span> matrices number 3 in all, as <span class="math notranslate nohighlight">\(t_{1} = -1\)</span>, <span class="math notranslate nohighlight">\(0\)</span>, or <span class="math notranslate nohighlight">\(1\)</span> in turn; only one of these matrices, <span class="math notranslate nohighlight">\([0]\)</span>, has zero determinant. (The one by one case is, well, done; the two by two case takes a few more computations but is within reach of hand computation; the three by three would count as punishment to have to do it by hand.  The general case seems very hard, and while we know the answer for the first few dimensions, we don’t know the answer in general. This is the first open question of this chapter/unit.)</p>
<p>To help you explore, you might start from the following Python code (which looks at <em>general</em> matrices, not this particular kind of matrix) or, of course, roll your own.</p>
<p>This is kind of a fundamental question: given the dimension, what is the probability that a system like this can be solved?</p>
<p><strong>Graduate Activity:</strong> We have run versions of this material on past graduate students. Here’s a question for such as they. Consider the <em>block</em> version of these matrices: replace each <span class="math notranslate nohighlight">\(t_{k}\)</span> with a matrix <span class="math notranslate nohighlight">\(\mathbf{T}_{k}\)</span>, say an <span class="math notranslate nohighlight">\(r \times r\)</span> matrix, and replace <span class="math notranslate nohighlight">\(-1\)</span> with <span class="math notranslate nohighlight">\(-\mathbf{I}\)</span> where <span class="math notranslate nohighlight">\(\mathbf{I}\)</span> is the <span class="math notranslate nohighlight">\(r\times r\)</span> identity matrix. Find the determinant of</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    \begin{bmatrix}
        \mathbf{T}_{1} &amp; \mathbf{T}_{2} &amp; \mathbf{T}_{3} &amp; \cdots &amp; \mathbf{T}_{n} \\
        -\mathbf{I} &amp; \mathbf{T}_{1} &amp; \mathbf{T}_{2} &amp; \cdots &amp; \mathbf{T}_{n-1} \\
        &amp; -\mathbf{I} &amp; \mathbf{T}_{1} &amp; &amp; \vdots \\
        &amp; &amp; \ddots &amp; \ddots &amp; \\
        &amp; &amp; &amp; -\mathbf{I} &amp; \mathbf{T}_{1}
    \end{bmatrix}
\end{equation*}\]</div>
<p>(rather, find a formula as the determinant of an <span class="math notranslate nohighlight">\(r\times r\)</span> matrix). We do know the answer to this problem. Now, if and only if each entry of each <span class="math notranslate nohighlight">\(\mathbf{T}_{k}\)</span> comes from <span class="math notranslate nohighlight">\(\{-1, 0, 1\}\)</span>, what is the probability that the big matrix is singular? We know <em>nothing</em> of that problem.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">population</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># Changed from [-1,0,1]</span>
<span class="n">mdim</span> <span class="o">=</span> <span class="mi">2</span>
<span class="c1"># Let&#39;s look at general mdim by mdim matrices (already by mdim=4 there are 43,046,721 matrices)</span>
<span class="n">sequencelength</span> <span class="o">=</span> <span class="n">mdim</span><span class="o">*</span><span class="n">mdim</span> <span class="c1"># There are sequencelength entries in each matrix</span>
<span class="c1"># Generate (one at a time) all possible choices for</span>
<span class="c1"># vector elements</span>
<span class="n">possibilities</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span> <span class="n">population</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="n">sequencelength</span> <span class="p">)</span>
<span class="n">possible</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">possibilities</span><span class="p">)</span>
<span class="c1"># Enumerate all lists of possible population choices</span>
<span class="n">nchoices</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">)</span><span class="o">**</span><span class="n">sequencelength</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The number of possible matrices is &quot;</span><span class="p">,</span> <span class="n">nchoices</span><span class="p">)</span>
<span class="n">nsingular</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nchoices</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">possible</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sequencelength</span><span class="p">)],(</span><span class="n">mdim</span><span class="p">,</span><span class="n">mdim</span><span class="p">))</span> <span class="c1"># make a matrix</span>
    <span class="c1">#dt = a[0,0]*a[1,1]-a[0,1]*a[1,0] in 2 by 2 case</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="c1"># Don&#39;t know if this will be numerically robust for mdim&gt;2</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">0.5</span><span class="p">:</span>
        <span class="n">nsingular</span> <span class="o">+=</span><span class="mi">1</span>
    <span class="c1">#print( a, dt )</span>
<span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;The number of singular matrices was &quot;</span><span class="p">,</span> <span class="n">nsingular</span><span class="p">,</span> <span class="s2">&quot;out of &quot;</span><span class="p">,</span> <span class="n">nchoices</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The number of possible matrices is  81
The number of singular matrices was  31 out of  81
</pre></div>
</div>
</div>
</div>
<div class="section" id="table-of-results">
<h3>Table of results<a class="headerlink" href="#table-of-results" title="Permalink to this headline">¶</a></h3>
<p>We ran the code above, which generates <em>general</em> Bohemian matrices (not Toeplitz upper Hessenberg) and counted the number of singular matrices with some different populations.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>m</p></th>
<th class="head"><p>(-1,0,1)</p></th>
<th class="head"><p>(i, 0, 1 )</p></th>
<th class="head"><p>(0,1,2)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>33</p></td>
<td><p>31</p></td>
<td><p>31</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>7,875</p></td>
<td><p>6,783</p></td>
<td><p>6,891</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>15,099,201</p></td>
<td><p>11,555,385</p></td>
<td><p>12,202,161</p></td>
</tr>
</tbody>
</table>
<p>At <span class="math notranslate nohighlight">\(m=1\)</span>, one third of the <span class="math notranslate nohighlight">\((-1,0,1)\)</span> matrices are singular; at <span class="math notranslate nohighlight">\(m=2\)</span>, <span class="math notranslate nohighlight">\(40.7\%\)</span> are; at <span class="math notranslate nohighlight">\(m=3\)</span>, <span class="math notranslate nohighlight">\(40\%\)</span> are; at <span class="math notranslate nohighlight">\(m=4\)</span>, <span class="math notranslate nohighlight">\(35\%\)</span> are.  To estimate the odds at higher dimension, we shall have to resort to sampling.  Two of those columns of counts agree with <a class="reference external" href="http://www.bohemianmatrices.com/cpdb/unstructured/">the tabulated at the Characteristic Polynomial Database, by the way</a>.  This increases our confidence in the <span class="math notranslate nohighlight">\((i,0,1)\)</span> column, which is not present at the CPDB.</p>
<p>Our original version of that code had the test <code class="docutils literal notranslate"><span class="pre">dt==0</span></code> instead of <code class="docutils literal notranslate"><span class="pre">abs(dt)&lt;0.5</span></code>.  After all, we were expecting integer arithmetic: the determinant of an integer matrix is always an integer (this is a fact that one learns on the side in a standard course; here it’s not at all obvious, especially so because we haven’t mentioned how to compute determinants in general; but it follows from the <a class="reference external" href="https://en.wikipedia.org/wiki/Determinant">so-called Leibniz formula in Wikipedia for the determinant</a> because the determinant is just a certain sum of certain products of the entries).
Using that test (<code class="docutils literal notranslate"><span class="pre">dt==0</span></code>) Python got the right number of singular matrices when <code class="docutils literal notranslate"><span class="pre">mdim=2</span></code> or <code class="docutils literal notranslate"><span class="pre">mdim=3</span></code>,  but the test <code class="docutils literal notranslate"><span class="pre">dt==0</span></code> failed a few times when <code class="docutils literal notranslate"><span class="pre">mdim=4</span></code>,
and (after a long time computing) reported 15,015,617 singular matrices; the true number is
15,099,201.  This is because <code class="docutils literal notranslate"><span class="pre">np.linalg.det</span></code> is computing the determinant from a numerical factoring (which introduces rational numbers and rounding error) and the roundoff error means that sometimes a zero determinant was not being reported as precisely zero.</p>
<p>We get better results with the test <code class="docutils literal notranslate"><span class="pre">abs(dt)</span> <span class="pre">&lt;</span> <span class="pre">0.5</span></code>. The determinant must be an integer; so if it’s smaller than 0.5,
it “must be zero.” This works, but induces some doubt (<em>could</em> the rounding errors ever be larger than <span class="math notranslate nohighlight">\(1/2\)</span>?).  We <em>could</em> do a numerical analysis of this, but…it’s not worth the effort anyway.</p>
<p>Indeed, for other reasons, that code above is ad-hoc and unsatisfactory.  As stated, its results are a little dubious (because it uses floating-point arithmetic to compute the determinant, and we really want an exact count; we think the answers are right, but we have not proved them). More than that, though, it’s a bit hard to change the matrix structure, to ask different questions.  It <em>is</em> easy to modify to ask (say) other questions about the determinant, such as “what is the largest determinant in absolute value” and “which matrices have this largest determinant”.  But we will share a better collection of Python routines later, which you can use and modify for your own experiments if you like.</p>
<p>But first let’s do a little more mathematics; let’s put aside our computations for a moment and consider a concept of very serious importance in applied and computational mathematics, namely <em>Eigenvalues</em>.  This concept is related to the notion of singularity as above, and requires a certain determinant to be zero; but let’s look at the details.</p>
</div>
</div>
<div class="section" id="eigenvalues">
<h2>Eigenvalues<a class="headerlink" href="#eigenvalues" title="Permalink to this headline">¶</a></h2>
<p>Matrices have many useful and interesting properties, but <em>eigenvalues</em> (also known as characteristic values) are especially important. Each eigenvalue comes paired with its own eigen<i>vector</i>. A usual symbol for an eigenvalue is <span class="math notranslate nohighlight">\(\lambda\)</span> (we don’t know why) while an eigenvector might be denited as <span class="math notranslate nohighlight">\(\overrightarrow{x}\)</span> (Or <span class="math notranslate nohighlight">\(v\)</span>; <span class="math notranslate nohighlight">\(v\)</span> is also common).  Here is how eigenvalues and eigenvectors work from a <em>formula</em> standpoint:</p>
<p>To the eigenvector <span class="math notranslate nohighlight">\(\overrightarrow{x}\)</span>, the matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> acts like the scalar <span class="math notranslate nohighlight">\(\lambda\)</span> (the eigen<i>value</i>):</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    \mathbf{A}\overrightarrow{x} = \lambda\overrightarrow{x} \&gt;.
\end{equation*}\]</div>
<p>This has a geometric interpretation in that the new vector <span class="math notranslate nohighlight">\(\mathbf{A}\overrightarrow{x}\)</span> is parallel and proportional to the old. It’s worth taking a minute to think about that: matrices act on vectors by multiplication and they produce other vectors (of the same size and orientation).  <em>Sometimes</em> this action is equivalent to multiplication by a scalar (which might be negative, or complex), but the direction of the eigenvector remains unchanged.</p>
<p>Algebraically this rearranges to</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    0 = (\mathbf{A}\overrightarrow{x} - \lambda\overrightarrow{x}) = (\mathbf{A} - \lambda\mathbf{I})\overrightarrow{x}
\end{equation*}\]</div>
<p>which you would learn in a standard linear algebra class implies that the determinant of <span class="math notranslate nohighlight">\(\mathbf{A} - \lambda\mathbf{I}\)</span> must be zero (there’s the connection to singularity).  There are also <em>left</em> eigenvectors, where you multiply on the left by a row vector, but we don’t need that here.</p>
<p>Let’s look at an example.  Consider the matrix</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\mathbf{A} = \left[\begin{array}{ccc}
-8 &amp; 11 &amp; -6 
\\
 -2 &amp; 5 &amp; -2 
\\
 8 &amp; -8 &amp; 6 
\end{array}\right]\&gt;,
\end{equation*}\]</div>
<p>and the vector <span class="math notranslate nohighlight">\([-1,0,1]^T\)</span>.  NB: The symbol <span class="math notranslate nohighlight">\({}^T\)</span> means <a class="reference external" href="https://en.wikipedia.org/wiki/Transpose">transpose</a>; we write column vectors as the transpose of a row vector to save space.  Python follows a convention popular among some mathematicians and does not distinguish between row vectors and column vectors, and prints all vectors horizontally (mostly one doesn’t want to print vectors, anyway—they’re usually too big).  Other systems, such as Maple and Matlab, follow another convention popular among other mathematicians and most scientists and engineers, and do distinguish between row vectors and column vectors.  Yes, it can be confusing.  “The nice thing about standards is that there’s so many to choose from.”  We will distinguish row and column vectors in the text but not (usually) in our code, because we almost always want column vectors and it doesn’t hurt to think of them that way.  You <em>can</em> distinguish in Python: treat an <span class="math notranslate nohighlight">\(n\)</span> by <span class="math notranslate nohighlight">\(1\)</span> matrix as a column vector, and a <span class="math notranslate nohighlight">\(1\)</span> by <span class="math notranslate nohighlight">\(m\)</span> matrix as a row vector. <strong>Remember to use .dot() to multiply matrices and vectors in Python.</strong></p>
<p>Back to the example.  Just multiplying out gives</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\left[\begin{array}{ccc}
-8 &amp; 11 &amp; -6 
\\
 -2 &amp; 5 &amp; -2 
\\
 8 &amp; -8 &amp; 6 
\end{array}\right]\begin{bmatrix} -1 \\ 0 \\ 1 \end{bmatrix} = \begin{bmatrix} 2 \\ 0 \\ -2 \end{bmatrix} = -2\begin{bmatrix} -1 \\ 0 \\ 1 \end{bmatrix}\&gt;.   
\end{equation*}\]</div>
<p>That is, to this one vector, the matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> acts just like the scalar <span class="math notranslate nohighlight">\(-2\)</span>.  We say <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> has the eigenvalue <span class="math notranslate nohighlight">\(\lambda = -2\)</span> corresponding to the eigenvector <span class="math notranslate nohighlight">\([-1,0,1]^T\)</span>.</p>
<p>The readers may verify, if they choose, that the vector <span class="math notranslate nohighlight">\([1,2,2]^T\)</span> is also an eigenvector, as is the vector <span class="math notranslate nohighlight">\([1,1,0]^T\)</span>, each with different eigenvalues (which can be discovered easily by doing the computation).</p>
<p>Once found, eigenvalues and eigenvectors are easy to deal with.  For this example we worked backwards, and chose the eigenvalues and eigenvectors so that these were all within reach of hand computation; indeed this is the kind of question one might find on a linear algebra exam: “Given the matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> above, find its eigenvalues and eigenvectors.”  The standard treatment leads to the cubic equation <span class="math notranslate nohighlight">\(\lambda^{3}-3 \lambda^{2}-4 \lambda +12=0\)</span>, which the examinee may also have to discover by hand computation. For the eigenvalues, the examinee is then expected to solve the cubic by trial and error (the answers are, as is typical only for examination questions, all integers).  Knowledge of the cubic formula is considered too esoteric, for most courses.  To be fair, the idea can go across with specially-constructed artificial problems that are easy for hand solution.</p>
<p>We’re not going to do that.  We’re going to use Python (or Maple or any other computer system) to find the eigenvalues for us (and eigenvectors, if we are looking for them).  And although our matrices will be all integers (sort of) we will not expect that the eigenvalues will be integers: indeed, “it is known” that <a class="reference external" href="https://www.jstor.org/stable/40391166">with probability <span class="math notranslate nohighlight">\(1\)</span> the eigenvalues will not be integers</a>. But in practice, with matrix structures, integer eigenvalues <em>do</em> occur; just not as often as they do on student exams.</p>
<p>Here are some Python matrix computations as examples.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">],(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;The matrix above is </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">A</span> <span class="p">)</span>
<span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;Its eigenvalues are &quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The matrix from the first cell was </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="n">e</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span> <span class="n">B</span> <span class="p">)</span>
<span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;Its eigenvalues are complex numbers (definitely not integers---this almost never happens in real life): </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;Its eigenvectors are </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;The matrix times the first eigenvector is &quot;</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
<span class="n">residual</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span> <span class="o">-</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;The difference to e[0]*v[:,0] is small: </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">residual</span> <span class="p">)</span>
<span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;The 2-norm of the residual is &quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span> <span class="n">residual</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span> <span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The matrix above is 
 [[-8 11 -6]
 [-2  5 -2]
 [ 8 -8  6]]
Its eigenvalues are  [-2.  3.  2.]
The matrix from the first cell was 
 [[-1  0  1  1]
 [ 1  1 -1  0]
 [ 0  0  1 -1]
 [-1 -1 -1  1]]
Its eigenvalues are complex numbers (definitely not integers---this almost never happens in real life): 
 [ 1.47356148+0.44477181j  1.47356148-0.44477181j -0.47356148+0.44477181j
 -0.47356148-0.44477181j]
Its eigenvectors are 
 [[ 0.14222565-0.05614572j  0.14222565+0.05614572j  0.8007498 +0.j
   0.8007498 -0.j        ]
 [-0.73106263+0.j         -0.73106263-0.j         -0.44271617-0.0188322j
  -0.44271617+0.0188322j ]
 [ 0.48842875+0.26901032j  0.48842875-0.26901032j  0.14000426+0.16915726j
   0.14000426-0.16915726j]
 [-0.11165283-0.34463227j -0.11165283+0.34463227j  0.28154127+0.18699368j
   0.28154127-0.18699368j]]
The matrix times the first eigenvector is  [ 0.23455027-0.01947622j -1.07726573-0.32515605j  0.60008158+0.61364259j
 -0.0112446 -0.55749687j]
The difference to e[0]*v[:,0] is small: 
 [-2.77555756e-17-1.24900090e-16j -8.88178420e-16-1.11022302e-16j
 -8.88178420e-16-6.66133815e-16j  7.07767178e-16+5.55111512e-16j]
The 2-norm of the residual is  1.690927436478955e-15
</pre></div>
</div>
</div>
</div>
<div class="section" id="a-useful-theorem-the-gerschgorin-circle-theorem">
<h3>A useful theorem: the Gerschgorin Circle Theorem<a class="headerlink" href="#a-useful-theorem-the-gerschgorin-circle-theorem" title="Permalink to this headline">¶</a></h3>
<p>The following simple rule is quite useful in helping us to choose plot ranges for eigenvalues.  It’s actually fairly simple to prove, too (once one has had enough experience with linear algebra).  See <a class="reference external" href="https://en.wikipedia.org/wiki/Gershgorin_circle_theorem">the Wikipedia article on the Gerschgorin theorem</a> for details, including a proof.  But we just want to <em>use</em> it, so what do we <em>do</em>?  Look at the diagonal entries <span class="math notranslate nohighlight">\(a_{ii}\)</span> and take circles centred at those points; the circles should have radius equal to the sum of the absolute values of all the <em>rest</em> of the entries from that same row.</p>
<p>All the eigenvalues of the matrix will be in the union of all those circles.  That’s all we’ll use.  Let’s do an example.  Take the matrix from the first cell,</p>
<div class="math notranslate nohighlight">
\[\begin{split}
B = \begin{bmatrix}
-1 &amp; \phantom{-}0 &amp; \phantom{-}1 &amp; \phantom{-}1 \\
\phantom{-}1  &amp; \phantom{-}1 &amp; -1 &amp; \phantom{-}0 \\
\phantom{-}0 &amp; \phantom{-}0 &amp; \phantom{-}1 &amp; -1 \\
-1 &amp; -1 &amp; -1 &amp; \phantom{-}1 
\end{bmatrix}\&gt;.
\end{split}\]</div>
<p>The first diagonal entry is <span class="math notranslate nohighlight">\(B_{0,0} = -1\)</span>.  The sum of the absolute values of the other entries in the row is <span class="math notranslate nohighlight">\(0 + 1 + 1 = 2\)</span>, so draw a circle of radius 2 centred at <span class="math notranslate nohighlight">\(z=-1\)</span> (red, below).  The second row has its diagonal entry <span class="math notranslate nohighlight">\(B_{11} = 1\)</span> so draw a circle (also of radius 2 because <span class="math notranslate nohighlight">\(1 + 1 + 0 = 2\)</span>) centred at 1 (blue, below).  The third circle is also centred at <span class="math notranslate nohighlight">\(1\)</span> but is radius just <span class="math notranslate nohighlight">\(1\)</span>; the fourth circle is centred at <span class="math notranslate nohighlight">\(1\)</span> and of radius <span class="math notranslate nohighlight">\(3\)</span>. This one dominates over the other two.  The eigenvalues must lie in the <em>union</em> of these circles.</p>
<p>You can use <em>columns</em> instead of rows; sometimes this gives a better picture.  There are other tricks, but this is enough for us for now; we’ll turbocharge this theorem a bit, later in this unit.</p>
<div class="section" id="formal-statement">
<h4>Formal statement<a class="headerlink" href="#formal-statement" title="Permalink to this headline">¶</a></h4>
<p>Reading those words above give the idea, but it might be helpful to be more precise.</p>
<div class="proof theorem admonition" id="gerschgorin">
<p class="admonition-title"><span class="caption-number">Theorem 1 </span> (Gerschgorin Circle Theorem)</p>
<div class="theorem-content section" id="proof-content">
<p>If a square matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> has entries <span class="math notranslate nohighlight">\(a_{i,j}\)</span>, then all eigenvalues <span class="math notranslate nohighlight">\(\lambda\)</span> of <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> are contained in the union of the circles <span class="math notranslate nohighlight">\(| z - a_{i,i}| \le R_i\)</span> with radii <span class="math notranslate nohighlight">\(R_i = \sum_{j\ne i} |a_{i,j}|\)</span>. Furthermore, if a subset of <span class="math notranslate nohighlight">\(\ell\)</span> of the circles forms a region disconnected from the other circles, then <span class="math notranslate nohighlight">\(\ell\)</span> of the eigenvalues will be in that region.</p>
</div>
</div><p><strong>Fourth Activity</strong> Consider the matrix</p>
<div class="amsmath math notranslate nohighlight" id="equation-0aaa79f7-92b0-4f05-9040-e25c0147566f">
<span class="eqno">(65)<a class="headerlink" href="#equation-0aaa79f7-92b0-4f05-9040-e25c0147566f" title="Permalink to this equation">¶</a></span>\[\begin{equation}
\mathbf{A} = \begin{bmatrix}
-5 &amp; 1 &amp; 1 
\\
 -1 &amp; 0 &amp; -1 
\\
 0 &amp; -1 &amp; 3 
\end{bmatrix}
\end{equation}\]</div>
<p>Draw—by hand—the Gerschgorin circles for this matrix.  Then compute the eigenvalues (by any method, but using Python is certainly ok) and verify that all the eigenvalues are in the union of the circles, and indeed that the “furthermore” part of the theorem is satisfied.</p>
<p><strong>Fifth Activity</strong> Consider the matrix</p>
<div class="amsmath math notranslate nohighlight" id="equation-245d0de8-228e-4163-8de6-987d60ff42cd">
<span class="eqno">(66)<a class="headerlink" href="#equation-245d0de8-228e-4163-8de6-987d60ff42cd" title="Permalink to this equation">¶</a></span>\[\begin{equation}
\mathbf{A} = \begin{bmatrix}
2 &amp; -1 &amp; 0 
\\
 -1 &amp; 2 &amp; -1 
\\
 0 &amp; -1 &amp; 2 
\end{bmatrix}
\end{equation}\]</div>
<p>Without computing the eigenvalues, can you decide if all of them are positive?  Do you think it’s at least possible?</p>
<p><strong>Sixth Activity</strong> Choose another matrix of your own and draw its Gershgorin circles and plot its eigenvalues.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Gerschgorinplot</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span> <span class="p">)</span>
<span class="n">circle0</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">circle0</span><span class="p">)</span>
<span class="n">circle1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">circle1</span><span class="p">)</span>
<span class="n">circle2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">circle2</span><span class="p">)</span>
<span class="n">circle3</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">circle3</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">ee</span><span class="o">.</span><span class="n">real</span> <span class="k">for</span> <span class="n">ee</span> <span class="ow">in</span> <span class="n">e</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">ee</span><span class="o">.</span><span class="n">imag</span> <span class="k">for</span> <span class="n">ee</span> <span class="ow">in</span> <span class="n">e</span><span class="p">]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="o">-</span><span class="mf">4.0</span><span class="p">,</span><span class="mf">5.0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">4.0</span><span class="p">,</span><span class="mf">4.0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/bohemian-matrices_20_0.png" src="../_images/bohemian-matrices_20_0.png" />
</div>
</div>
<div class="amsmath math notranslate nohighlight" id="equation-da052238-bc11-4065-9668-fcd96435ad5e">
<span class="eqno">(67)<a class="headerlink" href="#equation-da052238-bc11-4065-9668-fcd96435ad5e" title="Permalink to this equation">¶</a></span>\[\begin{equation}
\mathbf{A} = \left[\begin{array}{ccc}
-8 &amp; 11 &amp; -6 
\\
 -2 &amp; 5 &amp; -2 
\\
 8 &amp; -8 &amp; 6 
\end{array}\right]\&gt;,
\end{equation}\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Gerschgorinplot</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span> <span class="p">)</span>
<span class="n">circle0</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">((</span><span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">17</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">circle0</span><span class="p">)</span>
<span class="n">circle1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">4</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">circle1</span><span class="p">)</span>
<span class="n">circle2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">16</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">circle2</span><span class="p">)</span>
<span class="n">e</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span> <span class="p">]</span> <span class="c1"># From prior computation</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">ee</span><span class="o">.</span><span class="n">real</span> <span class="k">for</span> <span class="n">ee</span> <span class="ow">in</span> <span class="n">e</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">ee</span><span class="o">.</span><span class="n">imag</span> <span class="k">for</span> <span class="n">ee</span> <span class="ow">in</span> <span class="n">e</span><span class="p">]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="o">-</span><span class="mf">10.0</span><span class="p">,</span><span class="mf">26.0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">18.0</span><span class="p">,</span><span class="mf">18.0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/bohemian-matrices_22_0.png" src="../_images/bohemian-matrices_22_0.png" />
</div>
</div>
</div>
</div>
<div class="section" id="eigenvalues-of-the-bohemian-upper-hessenberg-toeplitz-family">
<h3>Eigenvalues of the Bohemian Upper Hessenberg Toeplitz family.<a class="headerlink" href="#eigenvalues-of-the-bohemian-upper-hessenberg-toeplitz-family" title="Permalink to this headline">¶</a></h3>
<p>Let’s look at eigenvalues using our Bohemian Upper Hessenberg Toeplitz family. The <span class="math notranslate nohighlight">\(1 \times 1\)</span> case is pretty silly: the matrix is <span class="math notranslate nohighlight">\([t_{1}]\)</span> and <span class="math notranslate nohighlight">\([t_{1}] - \lambda\cdot[1]\)</span> (the <span class="math notranslate nohighlight">\(1\times 1\)</span> identity matrix) is just <span class="math notranslate nohighlight">\([t_{1} - \lambda]\)</span> with determinant <span class="math notranslate nohighlight">\(t_{1} - \lambda\)</span>. This is zero if <span class="math notranslate nohighlight">\(\lambda = t_{1}\)</span>, whatever <span class="math notranslate nohighlight">\(t_{1}\)</span> is, <span class="math notranslate nohighlight">\(-1\)</span>, <span class="math notranslate nohighlight">\(0\)</span>, or <span class="math notranslate nohighlight">\(1\)</span>. We say that the one-by-one matrix <span class="math notranslate nohighlight">\([t_{1}]\)</span> has just one eigenvalue, and the eigenvalue <span class="math notranslate nohighlight">\(\lambda\)</span> is the same as the matrix entry.  Well, in retrospect this is kind of obvious: The matrix <span class="math notranslate nohighlight">\(A\)</span> acts like the scalar <span class="math notranslate nohighlight">\(\lambda\)</span> if <span class="math notranslate nohighlight">\(\lambda=t_1\)</span>; sure, that’s because the matrix in some sense is <em>only</em> the scalar <span class="math notranslate nohighlight">\(t_1\)</span>.  It couldn’t be anything else.</p>
<p>The <span class="math notranslate nohighlight">\(2\times 2\)</span> case is more interesting:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    \begin{bmatrix}
        t_{1} &amp; t_{2} \\
        -1 &amp; t_{1}
    \end{bmatrix}
    -\lambda
    \begin{bmatrix}
        1 &amp; 0 \\
        0 &amp; 1
    \end{bmatrix}=
    \begin{bmatrix}
        t_{1}-\lambda &amp; t_{2} \\
        -1 &amp; t_{1} - \lambda
    \end{bmatrix}
\end{equation*}\]</div>
<p>which is just the same kind of matrix we saw before with <span class="math notranslate nohighlight">\(t_{1}\)</span> replaced by <span class="math notranslate nohighlight">\(t_{1} - \lambda\)</span> (because the matrix is Toeplitz, constant along diagonals). The determinant is <span class="math notranslate nohighlight">\(t_{2} + (t_{1} - \lambda)^{2}\)</span> and for this to be zero we must have</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    (t_{1} - \lambda)^{2} = -t_{2} 
\end{equation*}\]</div>
<p>or</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    t_{1} - \lambda = \pm\sqrt{-t_{2}}
\end{equation*}\]</div>
<p>or</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    \lambda = t_{1} \mp \sqrt{-t_{2}}
\end{equation*}\]</div>
<p>In general, these eigenvalues are complex numbers.  As we will see below, we can get some amazing pictures from this family. As an aside, the Gerschgorin circle theorem says that both eigenvalues must lie in the union of circles centred at <span class="math notranslate nohighlight">\(t_1\)</span> and of radius at <span class="math notranslate nohighlight">\(1\)</span> (from the second row) or <span class="math notranslate nohighlight">\(|t_2|\)</span> from the first.  Looking at the exact eigenvalues, we see that this is true, and we are satisfied.</p>
<div class="figure align-default" id="smallexhaustivep5-p0-p1viridis-12n177147">
<a class="reference internal image-reference" href="../_images/SmallExhaustivep5_p0_p1viridis_12N177147.png"><img alt="../_images/SmallExhaustivep5_p0_p1viridis_12N177147.png" src="../_images/SmallExhaustivep5_p0_p1viridis_12N177147.png" style="height: 300px;" /></a>
<p class="caption"><span class="caption-number">Fig. 5 </span><span class="caption-text">Density plot of eigenvalues of the Bohemian Upper Hessenberg Toeplitz family plotted in the complex plane.</span><a class="headerlink" href="#smallexhaustivep5-p0-p1viridis-12n177147" title="Permalink to this image">¶</a></p>
</div>
<p><strong>Question:</strong> You counted <span class="math notranslate nohighlight">\(9 = 3^{2}\)</span> such <span class="math notranslate nohighlight">\(2\times 2\)</span> matrices, and each matrix has two eigenvalues. One thus naively expects <span class="math notranslate nohighlight">\(18\)</span> eigenvalues in all. This is not so, because some eigenvalues occur twice in the same matrix (if <span class="math notranslate nohighlight">\(t_{2} = 0\)</span>) and others are shared between matrices. How many distinct eigenvalues are there?</p>
<p>The <span class="math notranslate nohighlight">\(3\times 3\)</span> case gives the game away: the determinant of</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    \begin{bmatrix}
        t_{1} - \lambda &amp; t_{2} &amp; t_{3} \\
        -1 &amp; t_{1} - \lambda &amp; t_{2} \\
        &amp; -1 &amp; t_{1} - \lambda
    \end{bmatrix}
\end{equation*}\]</div>
<p>is <span class="math notranslate nohighlight">\(t_{3} + 2t_{2}(t_{1} - \lambda) + (t_{1} - \lambda)^{3}\)</span>, a cubic polynomial obtained by replacing every <span class="math notranslate nohighlight">\(t_{1}\)</span> by <span class="math notranslate nohighlight">\(t_{1} - \lambda\)</span> in the original formula <span class="math notranslate nohighlight">\(t_{3} + 2t_{2}t_{1} + t_{1}^{3}\)</span>.</p>
<p><strong>Question (Another open question):</strong> How many distinct eigenvalues arise from the <span class="math notranslate nohighlight">\(n\times n\)</span> Bohemian upper Hessenberg Toeplitz matrices?</p>
<p>We see a connection between eigenvalues and polynomials (the so-called “characteristic polynomial”).  The standard theory says that eigenvalues are the roots of these characteristic polynomials.  We have “reduced” the eigenvalue problem to two problems: compute the characteristic polynomial, and then find the roots of the characteristic polynomial.</p>
<p>Nowadays, we turn this on its head, though. We have robust software to solve eigenvalue problems directly. In Matlab, the command is <code class="docutils literal notranslate"><span class="pre">eig</span></code>, while in Maple it’s <code class="docutils literal notranslate"><span class="pre">Eigenvalues</span></code> in the Linear Algebra package. In Python there is <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.linalg.eigvals.html">numpy.linalg.eigvals</a> So we leave polynomials out of the equation for computing eigenvalues.  If we want eigenvalues, we compute them directly. This turns into a valuable tool (even for multivariate problems).</p>
<p>What was that special thing that we mentioned earlier about commuting matrices?  The special thing is that if <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> commute, that is, <span class="math notranslate nohighlight">\(\mathbf{A}\mathbf{B} = \mathbf{B}\mathbf{A}\)</span>, then they <em>share eigenvectors</em>.  Rather than give a proof here, we just ask you to try it and see.  Take a random matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>.  Make a matrix <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> by taking a polynomial combination of <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>—that is, choose some coefficients <span class="math notranslate nohighlight">\(c_0\)</span>, <span class="math notranslate nohighlight">\(c_1\)</span>, and so on; then put <span class="math notranslate nohighlight">\(\mathbf{B} = c_0 \mathbf{I} + c_1 \mathbf{B} + \cdots + c_k \mathbf{B}^k\)</span> will guarantee that <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> will commute.  Try it!</p>
<p>We’ll still use polynomials (sometimes) for <em>counting</em> eigenvalues and as occasional checks on our eigenvalue computations.  And if there are only a “few” polynomials (compared to the number of matrices) then we will use them instead, but cautiously.</p>
<p>But here ends our lightning introduction to Linear Algebra.</p>
<p>The code below uses the same method of iterative construction of all possible Bohemian matrices with the given population, but instead of computing determinants, it directly computes and plots eigenvalues.  This works for <em>very</em> small dimension, but the plot gets very crowded very quickly. To produce instead the nice images in the gallery at <a class="reference external" href="http://www.bohemianmatrices.com/gallery/">bohemianmatrices.com</a> we used <em>density plots</em>.  We will show you how to do these in Python shortly.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">population</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="n">j</span><span class="p">]</span>
<span class="n">mdim</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1"># Don&#39;t use mdim=4; there are more than 43 million cases</span>
<span class="c1"># Let&#39;s look at general (dense, or full) matrices of dimension mdim by mdim </span>
<span class="c1"># (don&#39;t use mdim too big here, the picture gets too crowded)</span>
<span class="n">sequencelength</span> <span class="o">=</span> <span class="n">mdim</span><span class="o">*</span><span class="n">mdim</span> <span class="c1"># There are sequencelength entries in each matrix</span>
<span class="c1"># Generate (one at a time) all possible choices for</span>
<span class="c1"># vector elements</span>
<span class="n">possibilities</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span> <span class="n">population</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="n">sequencelength</span> <span class="p">)</span>
<span class="n">possible</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">possibilities</span><span class="p">)</span>
<span class="c1"># Enumerate all lists of possible population choices</span>
<span class="n">nchoices</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">)</span><span class="o">**</span><span class="n">sequencelength</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The number of possible matrices is &quot;</span><span class="p">,</span> <span class="n">nchoices</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Each matrix has &quot;</span><span class="p">,</span> <span class="n">mdim</span><span class="p">,</span> <span class="s2">&quot;eigenvalues &quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;So the total number of eigenvalues will be &quot;</span><span class="p">,</span> <span class="n">mdim</span><span class="o">*</span><span class="n">nchoices</span> <span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Although, to be sure, some of those eigenvalues will be identical.&quot;</span><span class="p">)</span>
<span class="n">alleigs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">mdim</span><span class="o">*</span><span class="n">nchoices</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>  <span class="c1"># Preallocate the space (useful in some languages)</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nchoices</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">possible</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sequencelength</span><span class="p">)],(</span><span class="n">mdim</span><span class="p">,</span><span class="n">mdim</span><span class="p">))</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> 
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mdim</span><span class="p">):</span>
        <span class="n">alleigs</span><span class="p">[</span><span class="n">n</span><span class="o">*</span><span class="n">mdim</span><span class="o">+</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>  <span class="c1"># keep the eigenvalues in the big preallocated vector</span>

<span class="c1"># Now split the eigenvalues into real and imaginary parts</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">real</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">alleigs</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">imag</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">alleigs</span><span class="p">]</span>

<span class="c1"># A simple scatter plot of the eigenvalues.</span>
<span class="n">eigplot</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="o">-</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">3.0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">3.0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The number of possible matrices is  19683
Each matrix has  3 eigenvalues 
So the total number of eigenvalues will be  59049
Although, to be sure, some of those eigenvalues will be identical.
</pre></div>
</div>
<img alt="../_images/bohemian-matrices_26_1.png" src="../_images/bohemian-matrices_26_1.png" />
</div>
</div>
<p>Looking back at that picture, several questions occur immediately.  First, there are those big empty spaces around the integer eigenvalues!  Look at <span class="math notranslate nohighlight">\(0\)</span> in particular—it’s as if the eigenvalues are allergic to the zero eigenvalue!  But <span class="math notranslate nohighlight">\(0\)</span> actually occurs as an eigenvalue for a lot of those matrices: the zero dot in the middle gets hit a <em>lot</em> of times.  Then there are smaller holes around <span class="math notranslate nohighlight">\(-1\)</span>, <span class="math notranslate nohighlight">\(-2\)</span>, <span class="math notranslate nohighlight">\(1\)</span>, <span class="math notranslate nohighlight">\(1+i\)</span>, <span class="math notranslate nohighlight">\(i\)</span>, <span class="math notranslate nohighlight">\(-1+i\)</span>, <span class="math notranslate nohighlight">\(-1-i\)</span>, <span class="math notranslate nohighlight">\(-i\)</span>, <span class="math notranslate nohighlight">\(1-i\)</span>, and some others; maybe <span class="math notranslate nohighlight">\(\pm 2i\)</span>.  What is going on?</p>
<p>Second, the shape is asymmetric, with more eigenvalues on the left than on the right.  Why?  Is that an accident, or a consequence of something deeper?  Certainly we can’t answer these questions without further investigation.</p>
<p>Can you see any <em>other</em> interesting features of this graph?  What questions would <em>you</em> ask?  Write some down.</p>
<p>Some (maybe most) of the questions we have about pictures like these are actually open; <em>no one</em> knows the answers.</p>
<p>What to do if you solve one of the open problems listed here: write up your proof carefully, and sent it to a friendly journal. If you use Maple, we suggest the new journal, <a class="reference external" href="https://mapletransactions.org/index.php/maple">Maple Transactions</a>, or if not using Maple, ACM Communication in Computer Algebra; or perhaps the journal Experimental Mathematics. Please send us a copy too!</p>
<p>What to do it you find that sombody’s already solved one or more of these (and so the problem was <em>not</em> open and we just didn’t know): let us know!</p>
</div>
</div>
<div class="section" id="bohemian-matrices-population-and-structure">
<h2>Bohemian Matrices: Population and Structure<a class="headerlink" href="#bohemian-matrices-population-and-structure" title="Permalink to this headline">¶</a></h2>
<p>The set of possible entries of the matrices is called the <em>population</em> (a name coined by Cara Adams, while doing her BSc Honours Thesis on Bohemian Eigenvalues). For the introductory example, the population was <span class="math notranslate nohighlight">\(\mathbb{P} = \{-1, 0, 1\}\)</span>. This is quite an interesting population and we’ll use it frequently, but it’s by no means the only interesting one. Other examples include <span class="math notranslate nohighlight">\(\mathbb{P} = \{-2, -1, 0, 1, 2\}\)</span>, or <span class="math notranslate nohighlight">\(\mathbb{P} = \{-1, 1\}\)</span>, or <span class="math notranslate nohighlight">\(\mathbb{P} = \{0, 1\}\)</span>, or even <span class="math notranslate nohighlight">\(\mathbb{P} = \{-1, -i, 0, i, 1\}\)</span> where <span class="math notranslate nohighlight">\(i = (0, 1)\)</span> is the square root of <span class="math notranslate nohighlight">\(-1\)</span>.  Python uses the letter “j” for this, as is common in electrical engineering; one can use it in Python by writing a number as <span class="math notranslate nohighlight">\(1+0j\)</span> for the complex copy of the number <span class="math notranslate nohighlight">\(1\)</span>, for instance, or <span class="math notranslate nohighlight">\(3+2j\)</span> for the complex number <span class="math notranslate nohighlight">\(3 + 2\sqrt{-1}\)</span>, which we are used to writing as <span class="math notranslate nohighlight">\(3+2i\)</span>.  This works even if you have a variable named “j” that is doing something else: just don’t write <span class="math notranslate nohighlight">\(2*j\)</span> which would invoke that variable.  <span class="math notranslate nohighlight">\(2j\)</span> means <span class="math notranslate nohighlight">\(2\cdot\sqrt{-1}\)</span> whereas <span class="math notranslate nohighlight">\(2*j\)</span> means twice whatever you have in variable “j” (if you have one).</p>
<p>In the experimental setup described below we have found it useful to be <em>systematic</em> about this (at least a little bit).  In order to help keep things organized, we decided to codify the population being studied.  As a first step, we labelled the lattice of complex integers (also called <a class="reference external" href="https://en.wikipedia.org/wiki/Gaussian_integer">Gaussian Integers</a>). We start at zero with the label “0”; step to the right, and label <span class="math notranslate nohighlight">\((1,0) = 1 + 0i\)</span> as “1”; then go around the origin clockwise numbering each lattice point. When we reach <span class="math notranslate nohighlight">\((1,-1) = 1-i\)</span>, step up to the <span class="math notranslate nohighlight">\(x\)</span>-axis and to the right to <span class="math notranslate nohighlight">\((2,0) = 2 + 0i\)</span> and label that “9”. Do it again. The result is pictured here, going up to label “24”.  One could continue but this suffices to get the idea across.</p>
<!-- ![Labelled Lattice Points](/Figures/Bohemian Matrices/labelledlatticepoints.png)

![image.png](attachment:image.png)
 --><div class="figure align-default" id="labelled-lattice-points">
<a class="reference internal image-reference" href="../_images/labelledlatticepoints.png"><img alt="../_images/labelledlatticepoints.png" src="../_images/labelledlatticepoints.png" style="height: 300px;" /></a>
<p class="caption"><span class="caption-number">Fig. 6 </span><span class="caption-text">The labelling scheme for the points we commonly use as populations: 0 is 0, 1 is 1, 2 is 1+j, 3 is j, 4 is -1 + j, and so on.</span><a class="headerlink" href="#labelled-lattice-points" title="Permalink to this image">¶</a></p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">populationlist</span> <span class="o">=</span> <span class="p">[</span><span class="nb">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="nb">complex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="nb">complex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span><span class="nb">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span><span class="nb">complex</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span><span class="nb">complex</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="nb">complex</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="nb">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="nb">complex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                               <span class="nb">complex</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="nb">complex</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span><span class="nb">complex</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span><span class="nb">complex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span><span class="nb">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span><span class="nb">complex</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span><span class="nb">complex</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span><span class="nb">complex</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                               <span class="nb">complex</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="nb">complex</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="nb">complex</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span><span class="nb">complex</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span><span class="nb">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span><span class="nb">complex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span><span class="nb">complex</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span><span class="nb">complex</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
</pre></div>
</div>
</div>
</div>
<p>The idea is that the population <span class="math notranslate nohighlight">\((-1,0,1)\)</span> is encoded as the tuple 5, 0, 1; or <span class="math notranslate nohighlight">\((p_5, p_0, p_1)\)</span> if you prefer.  Order does not matter for us.  The population <span class="math notranslate nohighlight">\((0,i)\)</span> is encoded as the tuple 0, 3; or <span class="math notranslate nohighlight">\((p_0, p_3)\)</span> if you prefer.  This doesn’t allow for populations that contain other things, like <span class="math notranslate nohighlight">\(\pi\)</span> and so on; but there are an uncountable number of things that <em>could</em> happen and while no doubt there are better systems for more complicated situations, we’re going to stick to Gaussian integers for now, and so this system will suffice.  Now there is a natural stratification: populations with only one entry; then populations with only two entries, then three, and so on.  The notion of the height of the resulting matrix also shows up (sort of) in the size of the label for the entry.  We will try to record our images (or other data) in files with names that reflect the population, and we will use Python string manipulation to automatically generate those names as a hedge against human error, together with the dimension and the matrix structure, which we’ll talk about now.</p>
<p>The other main variable in the study of Bohemian matrices in the <em>structure</em> of the matrices in the family. The family in <a class="reference internal" href="#sec-a-lightning-introduction-to-matrices"><span class="std std-ref">Back to the math: A lightning introduction to matrices</span></a> was required to be zero below the 1<sup>st</sup> subdiagonal, have <span class="math notranslate nohighlight">\(-1\)</span> on its 1<sup>st</sup> subdiagonal, and be constant along each diagonal: each matrix was upper Hessenberg and Toeplitz. There are many named structures of matrices that occur in practice, owing to natural correlations in the system being modelled. Here are a few structures, with pictures of Bohemian eigenvalues using various populations.</p>
<div class="section" id="a-general-family-dense-or-full-matrices">
<h3>A. General family (“dense” or “full” matrices)<a class="headerlink" href="#a-general-family-dense-or-full-matrices" title="Permalink to this headline">¶</a></h3>
<p>Any entry of a general (or full or dense) matrix can be any selection from <span class="math notranslate nohighlight">\(\mathbb{P}\)</span>. Denoting the size of the population by the notation <span class="math notranslate nohighlight">\(\#P\)</span>, the number of different general Bohemian matrices of dimension <span class="math notranslate nohighlight">\(n\)</span> is</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    G(n) = \#P^{n^{2}} \&gt;.
\end{equation*}\]</div>
<p>For the case <span class="math notranslate nohighlight">\(\mathbb{P} = \{-1, 0, 1\}\)</span>, <span class="math notranslate nohighlight">\(\#P = 3\)</span> and there are <span class="math notranslate nohighlight">\(3^{1}\)</span> <span class="math notranslate nohighlight">\(1 \times 1\)</span> matrices, <span class="math notranslate nohighlight">\(3^{4} = 81\)</span> <span class="math notranslate nohighlight">\(2 \times 2\)</span> matrices, <span class="math notranslate nohighlight">\(3^{9} = 19,683\)</span> <span class="math notranslate nohighlight">\(3\times 3\)</span> matrices, <span class="math notranslate nohighlight">\(3^{16} = 43,046,721\)</span> <span class="math notranslate nohighlight">\(4\times 4\)</span> matrices, and <span class="math notranslate nohighlight">\(3^{25} = 847,288,309,473\)</span> (over <span class="math notranslate nohighlight">\(847\)</span> billion) <span class="math notranslate nohighlight">\(5\times 5\)</span> matrices. <span class="math notranslate nohighlight">\(G(n)\)</span> grows faster than exponentially; it grows faster than <span class="math notranslate nohighlight">\(n! = n(n-1)(n-2)\cdots2\cdot 1\)</span>. Much faster.
Most properties of the general family with a given population <span class="math notranslate nohighlight">\(\mathbb{P}\)</span> remain to be discovered, as we write this, even though several trillion matrix eigenproblems have been solved (mostly by Steven Thornton) in the search.</p>
<p>We have imported our own code for dealing with Bohemian matrices.  For various reasons, we decided on an object-oriented approach, which will allow you to extend the code with different structures in a (hopefully!) straightforward manner.</p>
<p>We do stress that the code is written for <em>readability</em> and for correctness on small matrices; it uses (in general) the so-called Fadeev-Leverrier method for computing the characteristic polynomial, which is known to be <span class="math notranslate nohighlight">\(O(n^4)\)</span> whereas the fastest general algorithms are <span class="math notranslate nohighlight">\(O(n^3)\)</span> (here <span class="math notranslate nohighlight">\(n\)</span> is the dimension of the problem).  Even for <span class="math notranslate nohighlight">\(n=4\)</span> this is too slow, really.  But it is <em>very simple</em> (as these things go) and so we have left it this way (for now).  For some of the structures (upper Hessenberg, and upper Hessenberg Toeplitz, we have implemented cheaper methods.</p>
<p>Have a look at the file <code class="docutils literal notranslate"><span class="pre">bohemian_inheritance.py</span></code> (use your favourite text editor, or, well, open the file in Jupyter notebooks).  Read the code.  Really.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">U</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">Bohemian</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">getMatrix</span><span class="p">()</span> <span class="c1"># This is Object-Oriented (OO) style.  Objects know things about themselves.</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Matrix:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of Matrix Entries:&#39;</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">getNumberOfMatrixEntries</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Characteristic Polynomial:&#39;</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">characteristicPolynomial</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Determinant:&#39;</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">determinant</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Matrix:
 [[-1  1 -1 -1]
 [ 0  1  1  1]
 [-1  1  1  1]
 [ 0  0  1  0]]
Number of Matrix Entries: 16
Characteristic Polynomial: [ 2  0 -4 -1  1]
Determinant: 2
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="o">.</span><span class="n">plotEig</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/bohemian-matrices_38_0.png" src="../_images/bohemian-matrices_38_0.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="n">Bohemian</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;B is</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">getMatrix</span><span class="p">())</span> <span class="c1"># Initially zero because why not?</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>B is
 [[0 0 0 0]
 [0 0 0 0]
 [0 0 0 0]
 [0 0 0 0]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">B</span><span class="o">.</span><span class="n">makeMatrix</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;B is now</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">getMatrix</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>B is now
 [[-1  1 -1 -1]
 [ 0  1  1  1]
 [-1  1  1  1]
 [ 0  0  1  0]]
</pre></div>
</div>
</div>
</div>
<p>Here are some examples of the kind of question one can investigate with this code. First, in what follows, we compute all the characteristic polynomials for all the matrices of a given dimension with the chosen population (we chose a 2-element population, <span class="math notranslate nohighlight">\(-1 \pm j\)</span>, for no particular reason), and look for one that occurs the most often (there may be more than one that occurs this often—this code is crude and just selects one that occurs the most number of times).  If we take mdim=3 and the population only has two elements, it takes a fraction of a second; if we take mdim=4, then it takes 17 seconds (<span class="math notranslate nohighlight">\(2^{16} = 65,536\)</span> matrices instead of <span class="math notranslate nohighlight">\(2^9 = 512\)</span>, which is 128 times as many; and they are bigger so the computation cost per matrix is also more).  If we tried mdim=5, then there would be <span class="math notranslate nohighlight">\(2^{25}\)</span> which is more than <span class="math notranslate nohighlight">\(32\)</span> million matrices, 512 times as many: we would expect it to take, say, <span class="math notranslate nohighlight">\(512 \cdot 17 \approx 8700\)</span> seconds or about <span class="math notranslate nohighlight">\(2.4\)</span> hours (but actually more because it’s working with <span class="math notranslate nohighlight">\(5\)</span> by <span class="math notranslate nohighlight">\(5\)</span> matrices instead of <span class="math notranslate nohighlight">\(4\)</span> by <span class="math notranslate nohighlight">\(4\)</span>, which suggests <span class="math notranslate nohighlight">\(6\)</span> hours rather than <span class="math notranslate nohighlight">\(2.4\)</span> (because an <span class="math notranslate nohighlight">\(O(N^4)\)</span> algorithm for characteristic polynomial is being used, which is inefficient: and <span class="math notranslate nohighlight">\((5/4)^4 \approx 2.4\)</span> as well; and <span class="math notranslate nohighlight">\(2.4\)</span> times <span class="math notranslate nohighlight">\(2.4\)</span> is about <span class="math notranslate nohighlight">\(6\)</span>.  So this exhaustive code is really only good for small dimension matrices!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mdim</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">Bohemian</span><span class="p">(</span><span class="n">mdim</span><span class="p">)</span>
<span class="n">pcode</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span> <span class="c1"># Code from the above figure: indexes into populationlist which was defined above.</span>
<span class="n">population</span> <span class="o">=</span> <span class="p">[</span><span class="n">populationlist</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pcode</span><span class="p">]</span>
<span class="n">sequencelength</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">getNumberOfMatrixEntries</span><span class="p">()</span>
<span class="n">numberpossible</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">)</span><span class="o">**</span><span class="n">sequencelength</span>  <span class="c1"># Each entry of the sequence is one of the population</span>
<span class="c1"># Generate (one at a time) all possible choices for</span>
<span class="c1"># vector elements: this is what itertools.product does for us.</span>
<span class="n">possibilities</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span> <span class="n">population</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="n">sequencelength</span> <span class="p">)</span>
<span class="n">possible</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">possibilities</span><span class="p">)</span>
<span class="c1"># We will count the number of unique characteristic polynomials.</span>
<span class="n">charpolys</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">maxcount</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">possibilities</span><span class="p">:</span>
    <span class="n">A</span><span class="o">.</span><span class="n">makeMatrix</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">cp</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">characteristicPolynomial</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">cp</span> <span class="ow">in</span> <span class="n">charpolys</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">charpolys</span><span class="p">[</span><span class="n">cp</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">charpolys</span><span class="p">[</span><span class="n">cp</span><span class="p">]</span><span class="o">&gt;</span><span class="n">maxcount</span><span class="p">:</span>
            <span class="n">maxcount</span> <span class="o">=</span> <span class="n">charpolys</span><span class="p">[</span><span class="n">cp</span><span class="p">]</span>
            <span class="n">mostcommon</span> <span class="o">=</span> <span class="n">cp</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="n">p</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">charpolys</span><span class="p">[</span><span class="n">cp</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">finish</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;Program took &quot;</span><span class="p">,</span> <span class="n">finish</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="s2">&quot; seconds </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;There are &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">charpolys</span><span class="p">),</span> <span class="s2">&quot;distinct characteristic polynomials, vs &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">)</span><span class="o">**</span><span class="n">sequencelength</span><span class="p">,</span> <span class="s2">&quot;matrices&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;A most common characteristic polynomial was &quot;</span><span class="p">,</span> <span class="n">mostcommon</span><span class="p">,</span> <span class="s2">&quot;which occurred &quot;</span><span class="p">,</span> <span class="n">maxcount</span><span class="p">,</span> <span class="s2">&quot;times &quot;</span><span class="p">)</span>
<span class="n">A</span><span class="o">.</span><span class="n">makeMatrix</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;One of its matrices was &quot;</span><span class="p">,</span><span class="n">A</span><span class="o">.</span><span class="n">getMatrix</span><span class="p">()</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Program took  0.051012277603149414  seconds 

There are  68 distinct characteristic polynomials, vs  512 matrices
A most common characteristic polynomial was  ((-0+0j), (-0+0j), (3-1j), (1+0j)) which occurred  18 times 
One of its matrices was  [[-1.-1.j -1.-1.j -1.-1.j]
 [-1.+1.j -1.+1.j -1.+1.j]
 [-1.+1.j -1.+1.j -1.+1.j]]
</pre></div>
</div>
</div>
</div>
<p>Another thing we can do is make density plots of the eigenvalues (we will explore this in more detail below, for other matrix structures).  First, we take a random sample of matrices, and time things.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Nsample</span> <span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="mi">5</span> <span class="c1"># a bit more than 5 minutes for 5 million matrices of dimension 5 (all of them in 40 minutes, maybe?)</span>
<span class="n">mdim</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">pcode</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="n">population</span> <span class="o">=</span> <span class="p">[</span><span class="n">populationlist</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pcode</span><span class="p">]</span> 
<span class="n">A</span> <span class="o">=</span> <span class="n">Bohemian</span><span class="p">(</span><span class="n">mdim</span><span class="p">)</span>
<span class="n">sequencelength</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">getNumberOfMatrixEntries</span><span class="p">()</span>
<span class="n">numberpossible</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">)</span><span class="o">**</span><span class="n">sequencelength</span>
<span class="nb">print</span><span class="p">(</span> <span class="n">sequencelength</span><span class="p">,</span> <span class="n">numberpossible</span> <span class="p">)</span>
<span class="c1"># Make this reproducible, for testing purposes: choose a seed</span>
<span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span> <span class="mi">21713</span> <span class="p">)</span>

<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="c1"># Found by experiment, but Gerschgorin could have told us</span>
<span class="n">nrow</span> <span class="o">=</span> <span class="mi">1200</span>
<span class="n">ncol</span> <span class="o">=</span> <span class="mi">1200</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">DensityPlot</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span><span class="p">)</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nsample</span><span class="p">):</span>
    <span class="n">A</span><span class="o">.</span><span class="n">makeMatrix</span><span class="p">([</span> <span class="n">population</span><span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">))]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sequencelength</span><span class="p">)])</span>
    <span class="n">image</span><span class="o">.</span><span class="n">addPoints</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">eig</span><span class="p">())</span>

<span class="c1"># We encode the population into a label which we will use for the filename.</span>
<span class="n">poplabel</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pcode</span><span class="p">])</span>
<span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;viridis&#39;</span>
<span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;../Supplementary Material/Bohemian/dense/pop_</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">N</span><span class="si">{}</span><span class="s1">.png&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">poplabel</span><span class="p">,</span><span class="n">cmap</span><span class="p">,</span><span class="n">mdim</span><span class="p">,</span><span class="n">Nsample</span><span class="p">)</span>
<span class="n">image</span><span class="o">.</span><span class="n">makeDensityPlot</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">fname</span><span class="p">,</span> <span class="n">bgcolor</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">colorscale</span><span class="o">=</span><span class="s2">&quot;cumulative&quot;</span><span class="p">)</span>
<span class="n">finish</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Took </span><span class="si">{}</span><span class="s2"> seconds to compute and plot &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">finish</span><span class="o">-</span><span class="n">start</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>25 33554432
</pre></div>
</div>
<img alt="../_images/bohemian-matrices_44_1.png" src="../_images/bohemian-matrices_44_1.png" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Took 36.20794320106506 seconds to compute and plot 
</pre></div>
</div>
</div>
</div>
<p>We are currently in a “how to do things in Python” mode and not in a “what does that picture <em>mean</em>” mode, but we really have to stop and ask some questions about that picture.  First, it kind of looks like a fish, to some of us.  There are certainly two portions, one that (sort of) looks like a fish tail, and the other like a fish body (complete with dorsal and ventral fins).  <a class="reference external" href="https://en.wikipedia.org/wiki/Ocean_sunfish">Maybe a sunfish</a> or <a class="reference external" href="https://en.wikipedia.org/wiki/Opah">Maybe a moonfish, or Opah</a>.  Ok, that’s just human pareidolia talking—we see patterns when there aren’t any.</p>
<p>But <em>why</em> are there two distinct blobs? (We don’t know).  Why does the “tail” look as though it’s got stripes? (We don’t know).  Why is the “body” quite round, except for the “fins”? (We don’t know). Why is there a diffraction pattern around the origin? (We <em>kind of</em> know). Why are there bright curved rays coming from <span class="math notranslate nohighlight">\(\pm i\)</span>? (We don’t know).  Why is there a bright line around the <span class="math notranslate nohighlight">\(y\)</span>-axis? (We maybe have an idea about that; but nobody has pursued that idea yet).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># We tried this with mdim = 4, first, and by sampling 5 million mdim=5 ones above, to get a sense of computing time.</span>
<span class="n">mdim</span> <span class="o">=</span> <span class="mi">5</span> <span class="c1"># We thought that this exhaustive computation would take about 40 minutes; it actually took about 33 minutes</span>
<span class="n">pcode</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="n">population</span> <span class="o">=</span> <span class="p">[</span><span class="n">populationlist</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pcode</span><span class="p">]</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">Bohemian</span><span class="p">(</span><span class="n">mdim</span><span class="p">)</span>
<span class="n">sequencelength</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">getNumberOfMatrixEntries</span><span class="p">()</span>
<span class="n">numberpossible</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">)</span><span class="o">**</span><span class="n">sequencelength</span>
<span class="nb">print</span><span class="p">(</span> <span class="n">sequencelength</span><span class="p">,</span> <span class="n">numberpossible</span> <span class="p">)</span>
<span class="n">possibilities</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span> <span class="n">population</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="n">sequencelength</span> <span class="p">)</span>
<span class="n">possible</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">possibilities</span><span class="p">)</span>
<span class="c1"># We will count the number of unique characteristic polynomials.</span>
<span class="n">charpolys</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># Make a dictionary of charpolys</span>
<span class="n">maxcount</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">6.5</span><span class="p">,</span><span class="mf">3.5</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="n">nrow</span> <span class="o">=</span> <span class="mi">1200</span>
<span class="n">ncol</span> <span class="o">=</span> <span class="mi">1200</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">DensityPlot</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span><span class="p">)</span>
<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">possibilities</span><span class="p">:</span>
    <span class="n">A</span><span class="o">.</span><span class="n">makeMatrix</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">image</span><span class="o">.</span><span class="n">addPoints</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">eig</span><span class="p">())</span>

<span class="n">poplabel</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pcode</span><span class="p">])</span>
<span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;viridis&#39;</span>
<span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;../Supplementary Material/Bohemian/dense/exhaustivep_</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">N</span><span class="si">{}</span><span class="s1">.png&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">poplabel</span><span class="p">,</span><span class="n">cmap</span><span class="p">,</span><span class="n">mdim</span><span class="p">,</span><span class="n">numberpossible</span><span class="p">)</span>
<span class="n">image</span><span class="o">.</span><span class="n">makeDensityPlot</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">fname</span><span class="p">,</span> <span class="n">bgcolor</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">colorscale</span><span class="o">=</span><span class="s2">&quot;cumulative&quot;</span><span class="p">)</span>
<span class="n">finish</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Took </span><span class="si">{}</span><span class="s2"> seconds to compute and plot &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">finish</span><span class="o">-</span><span class="n">start</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Once</span> <span class="n">built</span><span class="p">,</span> <span class="n">it</span><span class="s1">&#39;s easy to change colours</span>
<span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;ocean&#39;</span>
<span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;../Supplementary Material/Bohemian/dense/whiteexhaustivep_</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">N</span><span class="si">{}</span><span class="s1">.png&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">poplabel</span><span class="p">,</span><span class="n">cmap</span><span class="p">,</span><span class="n">mdim</span><span class="p">,</span><span class="n">numberpossible</span><span class="p">)</span>
<span class="n">image</span><span class="o">.</span><span class="n">makeDensityPlot</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">fname</span><span class="p">,</span> <span class="n">bgcolor</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">colorscale</span><span class="o">=</span><span class="s2">&quot;cumulative&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Probably a hundred puzzles arise from those pictures!  We suggest that you take some time and write down some questions that occur to you in looking at them.  Other questions that occurred to us include “Why are there holes near certain eigenvalues?” and “How can we predict ahead of time where all the eigenvalues will be?” and “Did we actually capture <em>all</em> the eigenvalues?”</p>
<p>Frankly, we don’t know the answers to most of those questions.  We are confident that you can come up with more questions that we can’t answer, either!  We’re curious as to what you come up with.</p>
<p><strong>Seventh Activity</strong> Come up with some questions!</p>
<p>Now let’s look at another class of Bohemian matrices: <em>symmetric</em> Bohemians.  We gave code for these in the file <code class="docutils literal notranslate"><span class="pre">bohemian_inheritance.py</span></code>, together with code for some other structures.</p>
</div>
<div class="section" id="b-symmetric-family">
<h3>B. Symmetric family<a class="headerlink" href="#b-symmetric-family" title="Permalink to this headline">¶</a></h3>
<p>A matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> is symmetric if <span class="math notranslate nohighlight">\(\mathbf{A} = \mathbf{A}^{T}\)</span>—the transpose operation rotates <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> <span class="math notranslate nohighlight">\(180^{\circ}\)</span> over its main diagonal: <span class="math notranslate nohighlight">\(a_{ij}^{T} = a_{ji}\)</span>,</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    \begin{bmatrix}
        1 &amp; 2 &amp; 3 \\
        4 &amp; 5 &amp; 6 \\
        7 &amp; 8 &amp; 9
    \end{bmatrix}^{\mathrm{T}} =
    \begin{bmatrix}
        1 &amp; 4 &amp; 7 \\
        2 &amp; 5 &amp; 8 \\
        3 &amp; 6 &amp; 9 \\
    \end{bmatrix}
\end{equation*}\]</div>
<p>—and <em>unitary</em> if <span class="math notranslate nohighlight">\(\mathbf{A} = \mathbf{A}^{\mathrm{H}} := \bar{\mathbf{A}}^{\mathrm{T}}\)</span> (take the complex conjugate and the transpose).</p>
<p>You will learn in a standard linear algebra course that eigenvalues of unitary matrices, and of <em>real</em> symmetric matrices, are real. The pictures of the eigenvalues of these matrices are best understood as distributions. These are very well studied families, especially in physics: see the <a class="reference external" href="https://en.wikipedia.org/wiki/Wigner_semicircle_distribution">Wigner semicircle distribution</a>.  We’re going to stay away from what’s known, but you should be aware that there is a lot of interest, both academic and engineering, in the topic of <em>Random Matrices</em> and especially of random symmetric matrices.</p>
<p>Much less is known about the eigenvalues of <em>complex symmetric</em> matrices (not unitary, and not real, but symmetric). For instance</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    \begin{bmatrix}
        2 &amp; i \\
        i &amp; 2
    \end{bmatrix}
\end{equation*}\]</div>
<p>is complex symmetric and has eigenvalues that satisfy <span class="math notranslate nohighlight">\((\lambda-2)^{2} + 1 = 0 \Rightarrow \lambda = 2 \pm i\)</span>. Bohemian eigenvalues of complex symmetric matrices with various populations <span class="math notranslate nohighlight">\(\mathbb{P}\)</span> (which have to include some non-real numbers to be interesting in this context) are almost completely unexplored.</p>
<p><strong>Eighth Activity:</strong> Choose a population of numbers (not necessarily integers, but include something complex like <span class="math notranslate nohighlight">\(i\)</span> or <span class="math notranslate nohighlight">\(\frac{1}{1+i}\)</span> or whatever) and a modest dimension, and plot the Bohemian eigenvalues of, say, a few million matrices from your chosen or invented matrix family. Discuss.</p>
<p><em>Remark.</em> <span class="math notranslate nohighlight">\(S_n= p^{\frac{n(n+1)}{2}}\)</span> is the number of symmetric <span class="math notranslate nohighlight">\(n \times n\)</span> matrices with entries from population <span class="math notranslate nohighlight">\(\mathbb{P}\)</span> of size <span class="math notranslate nohighlight">\(p\)</span>. Compute the first few for <span class="math notranslate nohighlight">\(p = 3\)</span> and see that these grow vastly more slowly than <span class="math notranslate nohighlight">\(p^{n^{2}}\)</span> but still vastly faster than factorial.</p>
<p>We have run the following code snippet with several different choices for mdim and population, and tabulated the results in the second cell below this one.  For some choices of mdim and population, the computation took hours; we saved the results and they can be read in again if we want to work with them.  This makes sense because there is very significant <em>compression</em> of the data because while there are a lot of matrices, there are vastly fewer characteristic polynomials: many matrices share characteristic polynomials, and therefore eigenvalues.</p>
<p>We used <a class="reference external" href="https://en.wikipedia.org/wiki/JSON">JSON</a> (JavaScript Object Notation) to save the data; it required a bit of fiddling because we were using tuples (representing polynomial coefficients) as dictionary keys, which JSON doesn’t like; so we have to convert those to strings before saving, and convert them back to tuples (using <code class="docutils literal notranslate"><span class="pre">ast.literal_eval</span></code>) once we read them it.  But this is simple enough.  One side benefit of using JSON is that Maple can read the files, too, so we can share data between Python and Maple.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mdim</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">Symmetric</span><span class="p">(</span><span class="n">mdim</span><span class="p">)</span>
<span class="n">pcode</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># again the same code</span>
<span class="n">poplabel</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pcode</span><span class="p">])</span>
<span class="n">population</span> <span class="o">=</span> <span class="p">[</span><span class="n">populationlist</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pcode</span><span class="p">]</span>
<span class="n">sequencelength</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">getNumberOfMatrixEntries</span><span class="p">()</span>
<span class="n">numberpossible</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">)</span><span class="o">**</span><span class="n">sequencelength</span>
<span class="c1"># Generate (one at a time) all possible choices for</span>
<span class="c1"># vector elements</span>
<span class="n">possibilities</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span> <span class="n">population</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="n">sequencelength</span> <span class="p">)</span>
<span class="n">possible</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">possibilities</span><span class="p">)</span>
<span class="n">charpolys</span> <span class="o">=</span> <span class="p">{}</span>

<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">possibilities</span><span class="p">:</span>
    <span class="n">A</span><span class="o">.</span><span class="n">makeMatrix</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">cp</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">characteristicPolynomial</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">cp</span> <span class="ow">in</span> <span class="n">charpolys</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">charpolys</span><span class="p">[</span><span class="n">cp</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">charpolys</span><span class="p">[</span><span class="n">cp</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">finish</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;Program took &quot;</span><span class="p">,</span> <span class="n">finish</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="s2">&quot; seconds </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;There are &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">charpolys</span><span class="p">),</span> <span class="s2">&quot;distinct characteristic polynomials, vs &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">)</span><span class="o">**</span><span class="n">sequencelength</span><span class="p">,</span> <span class="s2">&quot;matrices&quot;</span><span class="p">)</span>
<span class="c1"># #Now let&#39;s try to save that collection of characteristic polynomials (useful when mdim is large)</span>
<span class="c1"># </span>
<span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;../Supplementary Material/Bohemian/symmetric/exhaustivecharpolys_pop_</span><span class="si">{}</span><span class="s1">_m</span><span class="si">{}</span><span class="s1">_N</span><span class="si">{}</span><span class="s1">.json&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">poplabel</span><span class="p">,</span><span class="n">mdim</span><span class="p">,</span><span class="n">numberpossible</span><span class="p">)</span>
<span class="n">out_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
<span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">({</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">):</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">charpolys</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span> <span class="n">out_file</span><span class="p">)</span>
<span class="n">out_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Program took  13.492595672607422  seconds 

There are  489 distinct characteristic polynomials, vs  59049 matrices
</pre></div>
</div>
</div>
</div>
<div class="section" id="number-of-distinct-characteristic-polynomials-for-symmetric-bohemians-with-various-populations">
<h4>Number of distinct characteristic polynomials for symmetric Bohemians with various populations<a class="headerlink" href="#number-of-distinct-characteristic-polynomials-for-symmetric-bohemians-with-various-populations" title="Permalink to this headline">¶</a></h4>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>dimension</p></th>
<th class="head"><p><span class="math notranslate nohighlight">\((-1,1)\)</span></p></th>
<th class="head"><p><span class="math notranslate nohighlight">\((-1, i)\)</span></p></th>
<th class="head"><p><span class="math notranslate nohighlight">\((-1,0,i)\)</span></p></th>
<th class="head"><p><span class="math notranslate nohighlight">\((-1,i,-i)\)</span></p></th>
<th class="head"><p><span class="math notranslate nohighlight">\((-1,0,1)\)</span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>2 (2)</p></td>
<td><p>2 (2)</p></td>
<td><p>3 (3)</p></td>
<td><p>3 (3)</p></td>
<td><p>3 (3)</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>3 (8)</p></td>
<td><p>6 (8)</p></td>
<td><p>18 (27)</p></td>
<td><p>12 (27)</p></td>
<td><p>11 (27)</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>8 (64)</p></td>
<td><p>20 (64)</p></td>
<td><p>154 (729)</p></td>
<td><p>99 (729)</p></td>
<td><p>58 (729)</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>19 (1,024)</p></td>
<td><p>90 (1,024)</p></td>
<td><p>2900 (59,049)</p></td>
<td><p>1639 (59,049)</p></td>
<td><p>489 (59,049)</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>68 (32,768)</p></td>
<td><p>538 (32,768)</p></td>
<td><p>131196 (14,348,907)</p></td>
<td><p>75415 (14,347,907)</p></td>
<td><p>8977 (14,348,907)</p></td>
</tr>
</tbody>
</table>
<p>The number in brackets is the number of matrices with that population at that dimension.  We did not immediately run the program for n=5, anticipating that it would take too long. For dimension=5 and population = (-1,1) the program took over a hundred seconds. For dimension 4 and population = (-1,0,1) it took 75 seconds; this suggests that each of the nearly 60,000 computations was cheaper than (less than about half the cost of) the dimension 5 computations. A back-of-the-envelope estimate then suggested that filling in that bottom-corner entry would take about 11 hours of computation, requiring an overnight run. It actually took <span class="math notranslate nohighlight">\(42451\)</span> seconds, or <span class="math notranslate nohighlight">\(11.8\)</span> hours, which made one of us quite smug.  Perhaps surprisingly, the population <span class="math notranslate nohighlight">\((-1,0,i)\)</span> was much faster: at <span class="math notranslate nohighlight">\(m=5\)</span> the computation only took <span class="math notranslate nohighlight">\(2.5\)</span> hours.  We suspected that this was because floating-point arithmetic was used in that case; we changed to use floating-point in all cases and were pleasantly surprised when each of the 3-element population runs with <span class="math notranslate nohighlight">\(m=5\)</span> took about <span class="math notranslate nohighlight">\(2.5\)</span> hours, so all three could be done in a single run.</p>
<p>Now let us plot a <em>density plot</em> of the (real) eigenvalues of that symmetric case with <span class="math notranslate nohighlight">\(m=5\)</span> and population <span class="math notranslate nohighlight">\((-1,0,1)\)</span> which we just read in the polynomials for.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Read in the big pile of characteristic polynomials from the m=5 P=(-1,0,1) computation.</span>
<span class="n">mdim</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">Symmetric</span><span class="p">(</span><span class="n">mdim</span><span class="p">)</span>
<span class="n">pcode</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">poplabel</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pcode</span><span class="p">])</span>
<span class="n">population</span> <span class="o">=</span> <span class="p">[</span><span class="n">populationlist</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pcode</span><span class="p">]</span>
<span class="n">sequencelength</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">getNumberOfMatrixEntries</span><span class="p">()</span>
<span class="n">numberpossible</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">)</span><span class="o">**</span><span class="n">sequencelength</span>
<span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;../Supplementary Material/Bohemian/symmetric/exhaustivecharpolys_pop_</span><span class="si">{}</span><span class="s1">_m</span><span class="si">{}</span><span class="s1">_N</span><span class="si">{}</span><span class="s1">.json&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">poplabel</span><span class="p">,</span><span class="n">mdim</span><span class="p">,</span><span class="n">numberpossible</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span> <span class="n">fname</span> <span class="p">)</span>
<span class="n">in_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
<span class="n">saved_charpolys</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">in_file</span><span class="p">)</span>
<span class="n">in_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">charpoly_tuple_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">k</span><span class="p">):</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">saved_charpolys</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>../Supplementary Material/Bohemian/symmetric/exhaustivecharpolys_pop_5_0_1_m5_N14348907.json
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">nbins</span> <span class="o">=</span><span class="mi">4001</span> <span class="c1"># number of bins for the histogram count: x[k] = -5 + 10*k/nbins, 0 &lt;= k &lt;= nbins</span>
<span class="n">histo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span>
<span class="k">for</span> <span class="n">ptuple</span> <span class="ow">in</span> <span class="n">charpoly_tuple_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
    <span class="n">pol</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ptuple</span><span class="p">])</span>
    <span class="n">rts</span> <span class="o">=</span> <span class="n">pol</span><span class="o">.</span><span class="n">roots</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">rts</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span> <span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">real</span><span class="o">+</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="n">nbins</span><span class="o">/</span><span class="mi">10</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">k</span><span class="o">&gt;=</span><span class="n">nbins</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">nbins</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">histo</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">charpoly_tuple_dict</span><span class="p">[</span><span class="n">ptuple</span><span class="p">]</span>
<span class="n">big</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">histo</span><span class="p">)</span>
<span class="n">histplot</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span> <span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="n">k</span><span class="o">/</span><span class="n">nbins</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbins</span><span class="p">)],</span> <span class="n">histo</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">,</span><span class="n">nonpositive</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="o">-</span><span class="n">mdim</span><span class="p">,</span><span class="n">mdim</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">big</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/bohemian-matrices_55_0.png" src="../_images/bohemian-matrices_55_0.png" />
</div>
</div>
<p>That code above, after the multi-hour run to get the 8977 characteristic polynomials as recorded in the bottom right corner, does a histogram of those eigenvalues, which are all real. Here is that figure, simply read in: as you can see, there are decided gaps in the histogram (the vertical gaps at -2, -1, 0, 1, and 2; the horizontal gaps are just artifacts of counting). This means that there are fewer roots in the neighbourhood of those points.  This is the one-dimensional analogue of the “holes” in the complex plots that we saw before and will show you more of next.  Because the matrices are symmetric and the entries are real, all the eigenvalues are constrained to be real.</p>
<p>As we saw previously, we can also make a histogram (density plot) for <em>complex</em> eigenvalues.  We now talk about how to do that.</p>
<!-- For the population $(-1,0,i)$ above, with $m=5$, we read the data produced above into Maple and used our existing density plot software to make the following image:
 -->
<!-- ![Density plot of roots of all 131,196 degree 5 polynomials](FromPython.png)
 -->
<!-- This image is "upside-down" --- the $y$-axis is pointing downwards --- but gives a sense of where most eigenvalues lie in the rectangle $-5 \le \Re(\lambda) \le 3$ and $-3 \le \Im(\lambda) \le 5$.  Hotter colours indicate higher density. --></div>
</div>
<div class="section" id="c-skew-symmetric-matrices">
<h3>C. Skew-symmetric matrices<a class="headerlink" href="#c-skew-symmetric-matrices" title="Permalink to this headline">¶</a></h3>
<p>This family of matrices are also called antisymmetric matrices. Given a matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>, skew-symmetric matrices have <span class="math notranslate nohighlight">\(\mathbf{A} = -\mathbf{A}^{\mathrm{T}}\)</span>.</p>
<p><strong>Ninth Activity</strong> Choose a population <span class="math notranslate nohighlight">\(\mathbb{P}\)</span> (which now kind of includes <span class="math notranslate nohighlight">\(-c\)</span> if it includes <span class="math notranslate nohighlight">\(c\)</span>) and plot the eigenvalues of the <span class="math notranslate nohighlight">\(n \times n\)</span> skew-symmetric Bohemian matrices that result. Compare those on <strong><a class="reference external" href="http://www.bohemianmatrices.com/gallery/">bohemianmatrices.com/gallery</a></strong>. See also <a class="reference external" href="https://doi.org/10.5206/mt.v1i1.14039">What can we learn from Bohemian matrices?</a> and  <a class="reference external" href="https://mapletransactions.org/index.php/maple/article/view/14360">Skew-symmetric tridiagonal Bohemian matrices</a>.  Discuss.</p>
<p>Other questions that arise here (in those references) are, “how many matrices in this collection <em>only</em> have the zero eigenvalue?”  This kind of matrix is called “nilpotent” because <span class="math notranslate nohighlight">\(A^m = 0\)</span>, the zero matrix, if it only has zero eigenvalues. How many <em>normal</em> matrices are there?  (A matrix is called “normal” if it commutes with its transpose; normal matrices have lots of nice properties.  Not all matrices are normal, and indeed non-normality occurs in applications and has nontrivial consequences).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mdim</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">SkewSymmetric</span><span class="p">(</span><span class="n">mdim</span><span class="p">)</span>
<span class="n">pcode</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">population</span> <span class="o">=</span> <span class="p">[</span><span class="n">populationlist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pcode</span><span class="p">]</span>
<span class="n">sequencelength</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">getNumberOfMatrixEntries</span><span class="p">()</span>
<span class="n">possibilities</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="n">sequencelength</span><span class="p">)</span>
<span class="n">possible</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">possibilities</span><span class="p">)</span>
<span class="n">numberpossibilities</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">)</span><span class="o">**</span><span class="n">sequencelength</span>
<span class="n">nilpotents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="n">nils</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">normals</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">orthogonals</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">unitaries</span> <span class="o">=</span> <span class="p">[]</span>


<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numberpossibilities</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">possible</span><span class="p">)</span>
    <span class="n">A</span><span class="o">.</span><span class="n">makeMatrix</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">Ai</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">getMatrix</span><span class="p">()</span>
    <span class="n">At</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">Ai</span><span class="p">)</span> <span class="c1"># Ai.T if you prefer an OO style</span>
    <span class="n">Ah</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">Ai</span><span class="p">))</span> <span class="c1"># Ai.conj().T likewise</span>
    <span class="c1"># A matrix is &quot;normal&quot; if it commutes with its conjugate transpose</span>
    <span class="n">NN</span> <span class="o">=</span> <span class="n">Ai</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ah</span><span class="p">)</span> <span class="o">-</span> <span class="n">Ah</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ai</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">NN</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">normals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="c1"># A matrix is &quot;unitary&quot; if its conjugate transpose is its inverse</span>
    <span class="c1"># (So unitary matrices are &quot;normal&quot;)</span>
    <span class="n">UN</span> <span class="o">=</span> <span class="n">Ai</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ah</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">mdim</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">UN</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">unitaries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="c1"># A matrix is &quot;orthogonal&quot; if its simple transpose is its inverse</span>
    <span class="c1"># Double counting if Ai is real (then At = Ah)</span>
    <span class="n">UO</span> <span class="o">=</span> <span class="n">Ai</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">At</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">mdim</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">UO</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">orthogonals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">cp</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">characteristicPolynomial</span><span class="p">()</span>
    <span class="n">trail</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cp</span><span class="p">[:</span><span class="n">mdim</span><span class="p">])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">trail</span><span class="p">):</span>
        <span class="n">nils</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">nilpotents</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">cp</span><span class="p">))</span>
<span class="n">finish</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;Program took &quot;</span><span class="p">,</span> <span class="n">finish</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="s2">&quot; seconds </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;Found&quot;</span><span class="p">,</span> <span class="n">nils</span><span class="p">,</span> <span class="s2">&quot;nilpotent polynomial(s), vs &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">)</span><span class="o">**</span><span class="n">sequencelength</span><span class="p">,</span> <span class="s2">&quot;matrices&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;Found&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">normals</span><span class="p">),</span> <span class="s2">&quot;normal matrices&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;Found&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">unitaries</span><span class="p">),</span> <span class="s2">&quot;unitary matrices&quot;</span><span class="p">)</span>
<span class="n">A</span><span class="o">.</span><span class="n">makeMatrix</span><span class="p">(</span> <span class="n">orthogonals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
<span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;Found&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">orthogonals</span><span class="p">),</span> <span class="s2">&quot;orthogonal matrices, e.g. </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">getMatrix</span><span class="p">()</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Program took  0.2312312126159668  seconds 

Found 35 nilpotent polynomial(s), vs  729 matrices
Found 143 normal matrices
Found 12 unitary matrices
Found 3 orthogonal matrices, e.g. 
 [[ 0.+0.j  1.+0.j  0.+0.j  0.+0.j]
 [-1.-0.j  0.+0.j  0.+0.j  0.+0.j]
 [-0.-0.j -0.-0.j  0.+0.j  1.+0.j]
 [-0.-0.j -0.-0.j -1.-0.j  0.+0.j]]
</pre></div>
</div>
</div>
</div>
<p>The population <span class="math notranslate nohighlight">\([1,i]\)</span> is special amongst skew-symmetric <em>tridiagonal</em> matrices; if we include <span class="math notranslate nohighlight">\(0\)</span> in the population as well, then that family is included in the set of general skew-symmetric matrices.  We were interested in the number of nilpotent matrices in that family; this means that all eigenvalues are zero.  There are some, at every tested dimension (this is different to the tridiagonal case).</p>
</div>
<div class="section" id="d-toeplitz-matrices-hankel-matrices">
<h3>D. Toeplitz matrices, Hankel matrices<a class="headerlink" href="#d-toeplitz-matrices-hankel-matrices" title="Permalink to this headline">¶</a></h3>
<p>Toeplitz matrices are constant along diagonals:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    \begin{bmatrix}
        \pi &amp; 1 &amp; 7 &amp; -3 \\
        -1 &amp; \pi &amp; 1 &amp; 7 \\
        -2 &amp; -1 &amp; \pi &amp; 1 \\
        -3 &amp; -2 &amp; -1 &amp; \pi
    \end{bmatrix} .
\end{equation*}\]</div>
<p>Hankel matrices (named for <a class="reference external" href="https://en.wikipedia.org/wiki/Hermann_Hankel">Hermann Hankel</a>) are consant along <em>anti</em>-diagonals:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    \begin{bmatrix}
        -3 &amp; 7 &amp; 1 &amp; e \\
        7 &amp; 1 &amp; e &amp; -2 \\
        1 &amp; e &amp; -2 &amp; 2 \\
        e &amp; -2 &amp; 2 &amp; 4
    \end{bmatrix} .
\end{equation*}\]</div>
<p>If <em>J</em> is the “exchange matrix”, also called the SIP matrix for Self-Involutory Permutation matrix, also called the anti-identity, and H is a Hankel matrix, then T = HJ is a Toeplitz matrix.</p>
<p><strong>Tenth Activity</strong>: write your own class for Toeplitz matrices and choose a population and plot eigenvalues of all matrices of modest dimension.  You might also recapitulate some of the other questions above: what is the number of singular such matrices? The maximum determinant that can occur? The number of distinct characteristic polynomials?  The number of distinct eigenvalues (to answer that question precisely, you may have to resort to GCD computations).</p>
<p><strong>Remark</strong>: Toeplitz matrices turn out to be connected to some very deep mathematical waters indeed, and some of those deep currents turn out to be instrumental in explaining the appearance of many of the pictures of Bohemian upper Hessenberg Toeplitz matrices.  We (mostly) leave those explanations alone, here.</p>
</div>
<div class="section" id="e-circulant-matrices">
<h3>E. Circulant matrices<a class="headerlink" href="#e-circulant-matrices" title="Permalink to this headline">¶</a></h3>
<p>Circulant matrices are special Toeplitz matrices: each row is the previous row, rotated:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    \begin{bmatrix}
        a &amp; b &amp; c &amp; d &amp; e \\
        e &amp; a &amp; b &amp; c &amp; d \\
        d &amp; e &amp; a &amp; b &amp; c \\
        c &amp; d &amp; e &amp; a &amp; b \\
        b &amp; c &amp; d &amp; e &amp; a
    \end{bmatrix} .
\end{equation*}\]</div>
<p>(If the rows were rotated the other way, you would get special Hankel matrices instead.) Eigenvalues of these can be found by using the FFT. The first explorations of Bohemian circulant matrices were done by Jonathan Briño-Tarasoff, and there is work in progress by another student, Cristian Ardelean, and still more by Leili Rafiee Sevyeri.  There is still a lot unknown about Bohemian circulants.</p>
<p><strong>Eleventh Activity</strong> Write your own implementation of circulant matrices.  You may wish to start fresh, because these matrices have some very interesting properties, including that they are diagonalized by the FFT, and so computation with these matrices is orders of magnitude faster than computation with general matrices.</p>
<p>See <a class="reference external" href="http://www.bohemianmatrices.com/gallery/Circulant_15x15/">The Bohemian Matrix Gallery circulant image</a> created by Jonathan Briño-Tarasoff. Image is of eigenvalues of a sample of 5 million 15x15 circulant matrices. The entries are sampled from the set <span class="math notranslate nohighlight">\({-1, 0, 1}\)</span>. This plot is viewed on <span class="math notranslate nohighlight">\(-1 \le \Re(\lambda) \le 1\)</span>, <span class="math notranslate nohighlight">\(-1 \le \Im(\lambda) \le 1\)</span>.  In a larger window, the image appears circular.</p>
</div>
<div class="section" id="f-trididagonal-and-other-banded-matrices">
<h3>F. Trididagonal and other banded matrices<a class="headerlink" href="#f-trididagonal-and-other-banded-matrices" title="Permalink to this headline">¶</a></h3>
<p>A tridiagonal matrix has zero entries everywhere except on the subdiagonal, main diagonal, and superdiagonal: for example</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    \begin{bmatrix}
        2 &amp; -1 &amp; &amp; &amp; &amp; \\
        -1 &amp; 3 &amp; -1 &amp; &amp; &amp; \\
        &amp; -1 &amp; 4 &amp; -1 &amp; &amp; \\
        &amp; &amp; -1 &amp; 5 &amp; -1 &amp; \\
        &amp; &amp; &amp; -1 &amp; 6 &amp; -1 \\
        &amp; &amp; &amp; &amp; -1 &amp; 7
    \end{bmatrix}
\end{equation*}\]</div>
<p>is tridiagonal.</p>
<p>Pentadiagonal matrices are zero except on the <span class="math notranslate nohighlight">\(-2\)</span>, <span class="math notranslate nohighlight">\(-1\)</span>, <span class="math notranslate nohighlight">\(0\)</span>, <span class="math notranslate nohighlight">\(1\)</span>, and <span class="math notranslate nohighlight">\(2\)</span> diagonals:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    \begin{bmatrix}
        3 &amp; 3 &amp; 5 &amp; &amp; &amp; &amp; \\
        3 &amp; 3 &amp; 3 &amp; 5 &amp; &amp; &amp; \\
        5 &amp; 3 &amp; 3 &amp; 3 &amp; 5 &amp; &amp; \\
        &amp; 5 &amp; 3 &amp; 3 &amp; 3 &amp; 5 &amp; \\
        &amp; &amp; 5 &amp; 3 &amp; 3 &amp; 3 &amp; 5 \\
        &amp; &amp; &amp; 5 &amp; 3 &amp; 3 &amp; 3 \\
        &amp; &amp; &amp; &amp; 5 &amp; 3 &amp; 3
    \end{bmatrix} .
\end{equation*}\]</div>
<p>That artificial example was also symmetric, and Toeplitz.
More generally “banded” matrices might have <span class="math notranslate nohighlight">\(m\)</span> nonzero subdiagonals and <span class="math notranslate nohighlight">\(k\)</span> nonzero superdiagonals.</p>
<p>See Cara Adams’ <a class="reference external" href="http://www.bohemianmatrices.com/gallery/Tridiagonal_15x15_1/">picture of eigenvalues</a> of 100 million <span class="math notranslate nohighlight">\(15\times 15\)</span> tridiagonal matrices with entries chosen “at random” from <span class="math notranslate nohighlight">\(\mathbb{P}=\{-1, 0, 1\}\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mdim</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">population</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="n">j</span><span class="p">]</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">SkewSymmetricTridiagonal</span><span class="p">(</span><span class="n">mdim</span><span class="p">)</span>
<span class="n">sequencelength</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">getNumberOfMatrixEntries</span><span class="p">()</span>
<span class="n">numberpossible</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">)</span><span class="o">**</span><span class="n">sequencelength</span>
<span class="nb">print</span><span class="p">(</span> <span class="n">sequencelength</span><span class="p">,</span> <span class="n">numberpossible</span> <span class="p">)</span>
<span class="c1"># Make this reproducible, for testing purposes: choose a seed</span>
<span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span> <span class="mi">21713</span> <span class="p">)</span>
<span class="n">A</span><span class="o">.</span><span class="n">makeMatrix</span><span class="p">([</span> <span class="n">population</span><span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">))]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sequencelength</span><span class="p">)])</span>
<span class="n">cp</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">characteristicPolynomial</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cp</span><span class="p">)</span>
<span class="n">Pcp</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span> <span class="n">cp</span> <span class="p">)</span> <span class="c1"># z -2z^3 + z^5 = z(z^2-1)^2</span>
<span class="n">rts</span> <span class="o">=</span> <span class="n">Pcp</span><span class="o">.</span><span class="n">roots</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span> <span class="n">rts</span> <span class="p">)</span>
<span class="nb">print</span><span class="p">(</span> <span class="n">A</span><span class="o">.</span><span class="n">eig</span><span class="p">()</span> <span class="p">)</span> <span class="c1"># Same as the roots but in a different order and with different rounding errors</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4 16
[ 0.+0.j -1.+0.j  0.+0.j -2.+0.j  0.+0.j  1.+0.j]
[-1.55377397e+00+1.43114687e-17j -4.84067520e-17-6.43594253e-01j
 -1.19198278e-17+6.43594253e-01j  0.00000000e+00+0.00000000e+00j
  1.55377397e+00-3.60822483e-16j]
[ 1.55377397e+00-1.66533454e-16j -1.55377397e+00+4.00721123e-16j
 -1.00298335e-16+6.43594253e-01j -3.46362707e-17+4.19870087e-16j
  5.15335577e-17-6.43594253e-01j]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Nsample</span> <span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="mi">4</span> <span class="c1"># 36 seconds for 50,000 eigenvalues</span>
<span class="n">mdim</span> <span class="o">=</span> <span class="mi">31</span>
<span class="n">pcode</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">population</span> <span class="o">=</span> <span class="p">[</span><span class="n">populationlist</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pcode</span><span class="p">]</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">SkewSymmetricTridiagonal</span><span class="p">(</span><span class="n">mdim</span><span class="p">)</span>
<span class="n">sequencelength</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">getNumberOfMatrixEntries</span><span class="p">()</span>
<span class="n">numberpossible</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">)</span><span class="o">**</span><span class="n">sequencelength</span>
<span class="nb">print</span><span class="p">(</span> <span class="n">sequencelength</span><span class="p">,</span> <span class="n">numberpossible</span> <span class="p">)</span>
<span class="c1"># Make this reproducible, for testing purposes: choose a seed</span>
<span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span> <span class="mi">21713</span> <span class="p">)</span>

<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">nrow</span> <span class="o">=</span> <span class="mi">500</span>
<span class="n">ncol</span> <span class="o">=</span> <span class="mi">500</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">DensityPlot</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span><span class="p">)</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nsample</span><span class="p">):</span>
    <span class="n">A</span><span class="o">.</span><span class="n">makeMatrix</span><span class="p">([</span> <span class="n">population</span><span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">))]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sequencelength</span><span class="p">)])</span>
    <span class="n">image</span><span class="o">.</span><span class="n">addPoints</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">eig</span><span class="p">())</span>

<span class="n">poplabel</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pcode</span><span class="p">])</span>
<span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;viridis&#39;</span>
<span class="n">image</span><span class="o">.</span><span class="n">makeDensityPlot</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;../Supplementary Material/Bohemian/skewsymtri/pop_</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">N</span><span class="si">{}</span><span class="s1">.png&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pcode</span><span class="p">,</span><span class="n">cmap</span><span class="p">,</span><span class="n">mdim</span><span class="p">,</span><span class="n">Nsample</span><span class="p">),</span> <span class="n">bgcolor</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">colorscale</span><span class="o">=</span><span class="s2">&quot;cumulative&quot;</span><span class="p">)</span>
<span class="n">finish</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Took </span><span class="si">{}</span><span class="s2"> seconds to compute and plot &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">finish</span><span class="o">-</span><span class="n">start</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>30 1073741824
</pre></div>
</div>
<img alt="../_images/bohemian-matrices_66_1.png" src="../_images/bohemian-matrices_66_1.png" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Took 33.38298273086548 seconds to compute and plot 
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="g-upper-hessenberg-matrices">
<h3>G. Upper Hessenberg matrices<a class="headerlink" href="#g-upper-hessenberg-matrices" title="Permalink to this headline">¶</a></h3>
<p>Upper Hessenberg matrices occur in the numerical computation of eigenvalues: everything below the first subdiagonal is zero. More, if any entry on the first subdiagonal is zero, the eigenvalue problem reduces to two smaller ones; from our point of view we may insist on non-zero subdiagonal entries only. Here is a five-by-five example:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\left[\begin{array}{ccccc}
h_{0,0} &amp; h_{0,1} &amp; h_{0,2} &amp; h_{0,3} &amp; h_{0,4} 
\\
 h_{1,0} &amp; h_{1,1} &amp; h_{1,2} &amp; h_{1,3} &amp; h_{1,4} 
\\
 0 &amp; h_{2,1} &amp; h_{2,2} &amp; h_{2,3} &amp; h_{2,4} 
\\
 0 &amp; 0 &amp; h_{3,2} &amp; h_{3,3} &amp; h_{3,4} 
\\
 0 &amp; 0 &amp; 0 &amp; h_{4,3} &amp; h_{4,4} 
\end{array}\right]
\end{equation*}\]</div>
<p>There are <span class="math notranslate nohighlight">\(n + n-1 + n-2 + \cdots + 1 = n(n+1)/2\)</span> possible places in the upper triangle, including the diagonal; there are <span class="math notranslate nohighlight">\(n-1\)</span> places on the subdiagonal. If the population <span class="math notranslate nohighlight">\(P\)</span> has #<span class="math notranslate nohighlight">\(P = p\)</span> entries and <span class="math notranslate nohighlight">\(0 \in P\)</span>, then there are</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    H(n) = p^{{n(n+1)}/{2}}(p-1)^{n-1}
\end{equation*}\]</div>
<p>such matrices.   If <span class="math notranslate nohighlight">\(0 \notin \mathbb{P}\)</span>, then there are</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    \hat{H}(n) = p^{{n(n+1)}/{2} + n-1} = p^{n(n+3)/2 - 1}
\end{equation*}\]</div>
<p>such matrices.  This family has only just begun to be investigated; see <a class="reference external" href="https://arxiv.org/abs/1809.10653">this arXiv paper</a> which was later subsumed in <span id="id1">[<a class="reference internal" href="../references.html#id4">Chan <em>et al.</em>, 2020</a>]</span>.  The first example below is <em>unit</em> upper Hessenberg; each entry in the subdiagonal is <span class="math notranslate nohighlight">\(1\)</span>.  The example after that is <em>both</em> upper Hessenberg and Toeplitz: this combination makes the family more tractable.</p>
<div class="section" id="an-upgrade-of-gerschgorin-s-theorem-for-unit-upper-hessenberg-matrices">
<h4>An upgrade of Gerschgorin’s Theorem for unit upper Hessenberg matrices.<a class="headerlink" href="#an-upgrade-of-gerschgorin-s-theorem-for-unit-upper-hessenberg-matrices" title="Permalink to this headline">¶</a></h4>
<p>Suppose that <span class="math notranslate nohighlight">\(H\)</span> is unit upper Hessenberg, by which we mean that all the subdiagonal entries are <span class="math notranslate nohighlight">\(1\)</span>. For instance, take the 5 by 5 case below:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
H = \left[\begin{array}{ccccc}
h_{0,0} &amp; h_{0,1} &amp; h_{0,2} &amp; h_{0,3} &amp; h_{0,4} 
\\
 1 &amp; h_{1,1} &amp; h_{1,2} &amp; h_{1,3} &amp; h_{1,4} 
\\
 0 &amp; 1 &amp; h_{2,2} &amp; h_{2,3} &amp; h_{2,4} 
\\
 0 &amp; 0 &amp; 1 &amp; h_{3,3} &amp; h_{3,4} 
\\
 0 &amp; 0 &amp; 0 &amp; 1 &amp; h_{4,4} 
\end{array}\right] .
\end{equation*}\]</div>
<p>The Gerschgorin circle theorem, unadorned, says that the eigenvalues are in the union of the disks centred at <span class="math notranslate nohighlight">\(h_{0,0}\)</span>, <span class="math notranslate nohighlight">\(h_{1,1}\)</span>, <span class="math notranslate nohighlight">\(h_{2,2}\)</span>, <span class="math notranslate nohighlight">\(h_{3,3}\)</span>, and <span class="math notranslate nohighlight">\(h_{4,4}\)</span>, and the radii of those disks are bounded by the sums of the absolute values of the other row entries: <span class="math notranslate nohighlight">\(|h_{0,1}| + |h_{0,2}| + |h_{0,3}| + |h_{0,4}|\)</span> for the first row, and so on.  But each entry is at most the size of the largest entry in <span class="math notranslate nohighlight">\(P\)</span>—call that number <span class="math notranslate nohighlight">\(\| P \|\)</span> the <em>height</em> of the family.  So the radius of the first circle is at most <span class="math notranslate nohighlight">\((m-1)\|P\|\)</span> (if the matrix is dimension <span class="math notranslate nohighlight">\(m\)</span>; in the above example <span class="math notranslate nohighlight">\(m\)</span> is <span class="math notranslate nohighlight">\(5\)</span>). The second is at most <span class="math notranslate nohighlight">\(1 + (m-2)\|P\|\)</span>, and so on; the last one is at most <span class="math notranslate nohighlight">\(1\)</span>.  This is good, and tells us a region in the complex plane where all the eigenvalues can be.</p>
<p>But we can do better, for this family of matrices.  Multiply by <span class="math notranslate nohighlight">\(\mathbf{S} =\)</span> diag<span class="math notranslate nohighlight">\((1,r,r^2, \ldots, r^{m-1})\)</span> on one side, say the left, and by <span class="math notranslate nohighlight">\(\mathbf{S}^{-1}\)</span> on the other. This is a <a class="reference external" href="https://en.wikipedia.org/wiki/Matrix_similarity">similarity transformation</a> and does not change the eigenvalues, as you would learn in a standard linear algebra course.  The result is (for our five by five example)</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\left[\begin{array}{ccccc}
h_{0,0} &amp; \frac{h_{0,1}}{r} &amp; \frac{h_{0,2}}{r^{2}} &amp; \frac{h_{0,3}}{r^{3}} &amp; \frac{h_{0,4}}{r^{4}} 
\\
 r  &amp; h_{1,1} &amp; \frac{h_{1,2}}{r} &amp; \frac{h_{1,3}}{r^{2}} &amp; \frac{h_{1,4}}{r^{3}} 
\\
 0 &amp; r  &amp; h_{2,2} &amp; \frac{h_{2,3}}{r} &amp; \frac{h_{2,4}}{r^{2}} 
\\
 0 &amp; 0 &amp; r  &amp; h_{3,3} &amp; \frac{h_{3,4}}{r} 
\\
 0 &amp; 0 &amp; 0 &amp; r  &amp; h_{4,4} 
\end{array}\right]
\end{split}\]</div>
<p>Now the radius from the first row is bounded by <span class="math notranslate nohighlight">\((1/r + 1/r^2 \cdots 1/r^{m-1})\|P\|\)</span> which is less than the <em>infinite</em> geometric sum <span class="math notranslate nohighlight">\(1/(r(1-1/r)) = 1/(r-1)\)</span> times <span class="math notranslate nohighlight">\(\|P\|\)</span>, so long as <span class="math notranslate nohighlight">\(r &gt; 1\)</span> so the series converges.
Similarly, the radius of the next row (and all subsequent rows) is less than <span class="math notranslate nohighlight">\(r + \|P\|/(r-1) = 1 + r-1 + \| P\|/(r-1) \)</span>. This is always bigger than the radius from the first row.  This will be minimized over all choices of <span class="math notranslate nohighlight">\(r\)</span> if the two final terms in that equation (which when multiplied together are constant) are actually equal: <span class="math notranslate nohighlight">\((r-1)^2 = \|P\|\)</span>, or <span class="math notranslate nohighlight">\(r = 1 + \sqrt{\|P\|}\)</span>.  This gives a radius of at most <span class="math notranslate nohighlight">\(1 + 2\sqrt{\|P\|}\)</span>.  Thus we take circles centred at each <span class="math notranslate nohighlight">\(p \in P\)</span> of radius <span class="math notranslate nohighlight">\(1+2\sqrt{\|P\|}\)</span> and we are guaranteed that all eigenvalues of every member of the unit upper Hessenberg family lies within that set.</p>
<p>This turbocharges Gerschgorin a little bit: the plain Gerschgorin circle theorem gives a bound that depends on the dimension; this version gives a bound that depends only on the <em>square root</em> of the height of the population, and guarantees that the dimension won’t make a big difference.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mdim</span> <span class="o">=</span> <span class="mi">6</span>  <span class="c1"># mdim=6 takes about two minutes</span>
<span class="n">pcode</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="n">population</span> <span class="o">=</span> <span class="p">[</span><span class="n">populationlist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pcode</span><span class="p">]</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">UnitUpperHessenberg</span><span class="p">(</span><span class="n">mdim</span><span class="p">)</span>
<span class="n">sequencelength</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">getNumberOfMatrixEntries</span><span class="p">()</span>
<span class="n">numberpossible</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">)</span><span class="o">**</span><span class="n">sequencelength</span>
<span class="n">possibilities</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="n">sequencelength</span><span class="p">)</span>
<span class="n">possible</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">possibilities</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span> <span class="n">sequencelength</span><span class="p">,</span> <span class="n">numberpossible</span> <span class="p">)</span>
<span class="n">eigenvalues</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">possible</span><span class="p">:</span>
    <span class="n">A</span><span class="o">.</span><span class="n">makeMatrix</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">ev</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">eig</span><span class="p">()</span>  
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">ev</span><span class="p">:</span>
        <span class="n">eigenvalues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="n">finish</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Took </span><span class="si">{}</span><span class="s2"> seconds to compute the eigenvalues &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">finish</span><span class="o">-</span><span class="n">start</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>21 2097152
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Took 92.41344499588013 seconds to compute the eigenvalues 
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">nrow</span> <span class="o">=</span> <span class="mi">1800</span>
<span class="n">ncol</span> <span class="o">=</span> <span class="mi">1800</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">DensityPlot</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span><span class="p">)</span>
<span class="n">image</span><span class="o">.</span><span class="n">addPoints</span><span class="p">(</span> <span class="n">eigenvalues</span> <span class="p">)</span>
<span class="n">finish</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Took </span><span class="si">{}</span><span class="s2"> seconds to add eigenvalues to the image &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">finish</span><span class="o">-</span><span class="n">start</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Took 26.738973140716553 seconds to add eigenvalues to the image 
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">poplabel</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pcode</span><span class="p">])</span>
<span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;copper&#39;</span>
<span class="n">image</span><span class="o">.</span><span class="n">makeDensityPlot</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;../Supplementary Material/Bohemian/UnitUpperHessenberg/Exhaustivepop</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">by</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">N</span><span class="si">{}</span><span class="s1">.png&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">poplabel</span><span class="p">,</span><span class="n">nrow</span><span class="p">,</span><span class="n">ncol</span><span class="p">,</span><span class="n">cmap</span><span class="p">,</span><span class="n">mdim</span><span class="p">,</span><span class="n">numberpossible</span><span class="p">),</span> <span class="n">bgcolor</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">colorscale</span><span class="o">=</span><span class="s2">&quot;cumulative&quot;</span><span class="p">)</span>
<span class="n">finish</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Took </span><span class="si">{}</span><span class="s2"> seconds to colourize the image.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">finish</span><span class="o">-</span><span class="n">start</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/bohemian-matrices_71_0.png" src="../_images/bohemian-matrices_71_0.png" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Took 3.1221296787261963 seconds to colourize the image.
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mdim</span> <span class="o">=</span> <span class="mi">12</span> <span class="c1"># Exhaustive is ok with dimension 12: only 177,147 matrices</span>
<span class="n">pcode</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">population</span> <span class="o">=</span> <span class="p">[</span><span class="n">populationlist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pcode</span><span class="p">]</span> 
<span class="n">A</span> <span class="o">=</span> <span class="n">UHTZD</span><span class="p">(</span><span class="n">mdim</span><span class="p">)</span>
<span class="n">sequencelength</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">getNumberOfMatrixEntries</span><span class="p">()</span>
<span class="n">numberpossible</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">)</span><span class="o">**</span><span class="n">sequencelength</span>
<span class="n">possibilities</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="n">sequencelength</span><span class="p">)</span>
<span class="n">possible</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">possibilities</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span> <span class="n">sequencelength</span><span class="p">,</span> <span class="n">numberpossible</span> <span class="p">)</span>
<span class="n">eigenvalues</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">possible</span><span class="p">:</span>
    <span class="n">A</span><span class="o">.</span><span class="n">makeMatrix</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">ev</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">eig</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">ev</span><span class="p">:</span>
        <span class="n">eigenvalues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

<span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">nrow</span> <span class="o">=</span> <span class="mi">1200</span>
<span class="n">ncol</span> <span class="o">=</span> <span class="mi">1200</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">DensityPlot</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span><span class="p">)</span>
<span class="n">image</span><span class="o">.</span><span class="n">addPoints</span><span class="p">(</span> <span class="n">eigenvalues</span> <span class="p">)</span>
<span class="n">poplabel</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pcode</span><span class="p">])</span>
<span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;viridis&#39;</span>
<span class="n">image</span><span class="o">.</span><span class="n">makeDensityPlot</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;../Supplementary Material/Bohemian/UHTZD/Exhaustivepop_</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">N</span><span class="si">{}</span><span class="s1">.png&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">poplabel</span><span class="p">,</span><span class="n">cmap</span><span class="p">,</span><span class="n">mdim</span><span class="p">,</span><span class="n">numberpossible</span><span class="p">),</span> <span class="n">bgcolor</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">colorscale</span><span class="o">=</span><span class="s2">&quot;cumulative&quot;</span><span class="p">)</span>
<span class="n">finish</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Took </span><span class="si">{}</span><span class="s2"> seconds to compute and plot &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">finish</span><span class="o">-</span><span class="n">start</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>11 177147
</pre></div>
</div>
<img alt="../_images/bohemian-matrices_72_1.png" src="../_images/bohemian-matrices_72_1.png" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Took 24.010122776031494 seconds to compute and plot 
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="h-frobenius-companion-matrices">
<h3>H. Frobenius companion matrices<a class="headerlink" href="#h-frobenius-companion-matrices" title="Permalink to this headline">¶</a></h3>
<p>Given a polynomial, say,</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    q(x) = q_{0} + q_{1}x + q_{2}x^{2} + q_{3}x^{3} + x^{4}
\end{equation*}\]</div>
<p>we can write down several matrices; for example</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    \mathbf{Q} = 
    \begin{bmatrix}
        0 &amp; 0 &amp; 0 &amp; -q_{0} \\
        1 &amp; 0 &amp; 0 &amp; -q_{1} \\
        &amp; 1 &amp; 0 &amp; -q_{2} \\
        &amp; &amp; 1 &amp; -q_{3}
    \end{bmatrix}
\end{equation*}\]</div>
<p>whose eigenvalues are the roots of the original polynomial. Such matrices are called “Frobenius companion” matrices. This is how Matlab actually solves polynomials, by the way.</p>
<p>These are very well studied, but there’s still more to learn. See <span id="id2">[<a class="reference internal" href="../references.html#id5">Borwein and Jörgenson, 2001</a>]</span>, <span id="id3">[<a class="reference internal" href="../references.html#id6">Borwein and Pinner, 1997</a>]</span>, <a class="reference external" href="http://math.ucr.edu/home/baez/">John Baez’s website</a>, and <a class="reference external" href="http://jdc.math.uwo.ca/">Dan Christensen’s website</a>.</p>
</div>
<div class="section" id="i-generalized-companion-matrices">
<h3>I. Generalized companion matrices<a class="headerlink" href="#i-generalized-companion-matrices" title="Permalink to this headline">¶</a></h3>
<p>Generalized companion matrices are also sometimes known as “colleague” matrices or “comrade” matrices.</p>
<p>Polynomials do not have to be expressed as linear combinations of the functions <span class="math notranslate nohighlight">\(1\)</span>, <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(x^{2}\)</span>, <span class="math notranslate nohighlight">\(\ldots\)</span>, <span class="math notranslate nohighlight">\(x^{n}\)</span>. This set forms a basis for polynomials of degree at most <span class="math notranslate nohighlight">\(n\)</span>, it is true, but there are thousands of other named bases (actually an uncountable number, but only a finite number of names to go round!). The restriction to a Bohemian family does different things in different bases. For instance, consider a Lagrange basis on the distinct nodes <span class="math notranslate nohighlight">\([-1, -\frac{1}{2}, \frac{1}{2}, 1]\)</span>; that is, the roots of the node polynomial</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    w(z) = (z + 1)(z + \frac{1}{2})(z - \frac{1}{2})(z - 1) \&gt;.
\end{equation*}\]</div>
<p>Computing the partial fraction decomposition of</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    \frac{1}{w(z)} = \frac{\beta_{-1}}{z + 1} + \frac{\beta_{-\frac{1}{2}}}{z + \frac{1}{2}} + \frac{\beta_{\frac{1}{2}}}{z - \frac{1}{2}} + \frac{\beta_{1}}{z - 1}
\end{equation*}\]</div>
<p>we find the numerical values of the “barycentric weights” <span class="math notranslate nohighlight">\(\beta_k\)</span>: <span class="math notranslate nohighlight">\(-2/3\)</span>, <span class="math notranslate nohighlight">\(4/3\)</span>, <span class="math notranslate nohighlight">\(-4/3\)</span>, and <span class="math notranslate nohighlight">\(2/3\)</span>.
Then if a polynomial <span class="math notranslate nohighlight">\(q(z)\)</span> takes the value <span class="math notranslate nohighlight">\(q_{-1}\)</span>, <span class="math notranslate nohighlight">\(q_{-\frac{1}{2}}\)</span>, <span class="math notranslate nohighlight">\(q_{\frac{1}{2}}\)</span>, and <span class="math notranslate nohighlight">\(q_{1}\)</span> (from a population <span class="math notranslate nohighlight">\(\mathbb{P}\)</span>), the roots of <span class="math notranslate nohighlight">\(q(z)\)</span> are the generalized eigenvalues of the pair <span class="math notranslate nohighlight">\((\mathbf{B}, \mathbf{A})\)</span></p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    \begin{bmatrix}
        0 &amp; &amp; &amp; &amp; \\
        &amp; 1 &amp; &amp; &amp; \\
        &amp; &amp; 1 &amp; &amp; \\
        &amp; &amp; &amp; 1 &amp; \\
        &amp; &amp; &amp; &amp; 1
    \end{bmatrix} \quad , \quad
    \begin{bmatrix}
        0 &amp; \beta_{-1} &amp; \beta_{-\frac{1}{2}} &amp; \beta_{\frac{1}{2}} &amp; \beta_{1} \\
        q_{-1} &amp; -1 &amp; &amp; &amp; \\
        q_{-\frac{1}{2}} &amp; &amp; -\frac{1}{2} &amp; &amp; \\
        q_{\frac{1}{2}} &amp; &amp; &amp; \frac{1}{2} &amp; \\
        q_{1} &amp; &amp; &amp; &amp; 1
    \end{bmatrix}
\end{equation*}\]</div>
<p>Matlab’s <code class="docutils literal notranslate"><span class="pre">eig</span></code> routine (and Maple’s) will accept pairs of matrices: to find <span class="math notranslate nohighlight">\(z\)</span> with <span class="math notranslate nohighlight">\(\mathrm{det}(z\mathbf{B} - \mathbf{A}) = 0\)</span>, equivalently <span class="math notranslate nohighlight">\(\mathrm{det}(\mathbf{A} - z\mathbf{B}) = 0\)</span>, call <span class="math notranslate nohighlight">\(\mathrm{eig}(\mathbf{A}, \mathbf{B})\)</span> (the order of the call is important <span class="math notranslate nohighlight">\(z\mathbf{B} - \mathbf{A}\)</span> is different to <span class="math notranslate nohighlight">\(z\mathbf{A} - \mathbf{B}\)</span>).  In Python, you have to use <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.eig.html">scipy.linalg.eig</a> to solve the generalized eigenvalue problem.</p>
<p>Lagrange basis companion eigenvalue problems were the first Bohemian eigenvalue problems solved, in 2004, although the name wasn’t invented then.</p>
<p>Note that the population <span class="math notranslate nohighlight">\(\mathbb{P}\)</span> is augmented by the nodes and the barycentric weights <span class="math notranslate nohighlight">\(\beta\)</span> in a special way.</p>
</div>
<div class="section" id="j-anti-tridiagonal-matrices-and-anti-banded-matrices">
<h3>J. Anti-tridiagonal matrices and anti-banded matrices<a class="headerlink" href="#j-anti-tridiagonal-matrices-and-anti-banded-matrices" title="Permalink to this headline">¶</a></h3>
<p>One of our students made these categories up (we have never seen them used in practice)  Anti-tridiagonal matrices and anti-banded matrices such as</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    \begin{bmatrix}
        &amp; &amp; &amp; &amp; 1 &amp; 2 \\
        &amp; &amp; &amp; 1 &amp; 2 &amp; 3 \\
        &amp; &amp; 1 &amp; 2 &amp; 3 &amp; \\
        &amp; 1 &amp; 2 &amp; 3 &amp; &amp; \\
        1 &amp; 2 &amp; 3 &amp; &amp; &amp; \\
        2 &amp; 3 &amp; &amp; &amp; &amp;
    \end{bmatrix}
\end{equation*}\]</div>
<p>produce interesting pictures.</p>
</div>
<div class="section" id="k-generalized-bohemian-eigenvalues">
<h3>K. Generalized Bohemian eigenvalues<a class="headerlink" href="#k-generalized-bohemian-eigenvalues" title="Permalink to this headline">¶</a></h3>
<p>Eigenvalues of <span class="math notranslate nohighlight">\(z\mathbf{B} - \mathbf{A}\)</span> where <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> are Bohemian, of any families. Almost nothing is known here.</p>
</div>
<div class="section" id="l-polynomial-eigenvalues-in-bohemia">
<h3>L. Polynomial eigenvalues in Bohemia<a class="headerlink" href="#l-polynomial-eigenvalues-in-bohemia" title="Permalink to this headline">¶</a></h3>
<p><span class="math notranslate nohighlight">\(\mathrm{det}\mathbf{Q}(z) = 0\)</span> where</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    \mathbf{Q}(z) = \mathbf{Q}_{0} + z\mathbf{Q}_{1} + z^{2}\mathbf{Q}_{2} + \cdots + z^{r}\mathbf{Q}_{rm}
\end{equation*}\]</div>
<p>and each <span class="math notranslate nohighlight">\(\mathbf{Q}_{i}\)</span> is an <span class="math notranslate nohighlight">\(r \times r\)</span> Bohemian. Basically, nothing is known here and we have very few pictures.</p>
</div>
<div class="section" id="m-higher-dimensions">
<h3>M. Higher dimensions<a class="headerlink" href="#m-higher-dimensions" title="Permalink to this headline">¶</a></h3>
<p>If we have two polynomial equations in two unknowns, for example</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
    x^{2} + y^{2} - 1 &amp;= 0 \\
    25xy - 12 &amp;= 0
\end{align*}\]</div>
<p>then we can find a pair of matrices <span class="math notranslate nohighlight">\(\mathbf{M}_{x}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{M}_{y}\)</span> such that the matrices commute <span class="math notranslate nohighlight">\(\mathbf{M}_{x}\mathbf{M}_{y} = \mathbf{M}_{y}\mathbf{M}_{x}\)</span> and share eigenvectors; <span class="math notranslate nohighlight">\(\mathbf{M}_{x}\overrightarrow{u} = x\overrightarrow{u}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{M}_{y}\overrightarrow{u} = y \overrightarrow{u}\)</span>; these eigenvalues <span class="math notranslate nohighlight">\((x, y)\)</span> will solve the system. This is the multidimensional analogue of companion matrices.</p>
<p><strong>Twelfth Activity:</strong> Find all pairs of commuting Bohemian matrices from a given population, and graphically display the correct pairs of eigenvalues. This is hard.</p>
</div>
<div class="section" id="n-doubly-companion-matrices">
<h3>N. Doubly companion matrices<a class="headerlink" href="#n-doubly-companion-matrices" title="Permalink to this headline">¶</a></h3>
<p>The “doubly” companion matrix was invented by John C. Butcher and co-workers in order to study certain methods for solving differential equations numerically.  So far as we know, they have no other use.  But they do make interesting Bohemian pictures and there are many unanswered questions about those pictures.  Here is a five by five example <em>doubly companion matrix</em> :</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\left[\begin{array}{ccccc}
-\alpha_{1} &amp; -\alpha_{2} &amp; -\alpha_{3} &amp; -\alpha_{4} &amp; -\alpha_{5}-\beta_{5} 
\\
 1 &amp; 0 &amp; 0 &amp; 0 &amp; -\beta_{4} 
\\
 0 &amp; 1 &amp; 0 &amp; 0 &amp; -\beta_{3} 
\\
 0 &amp; 0 &amp; 1 &amp; 0 &amp; -\beta_{2} 
\\
 0 &amp; 0 &amp; 0 &amp; 1 &amp; -\beta_{1} 
\end{array}\right]
\end{split}\]</div>
<p>The dimension <span class="math notranslate nohighlight">\(m\)</span> doubly companion matrix takes <span class="math notranslate nohighlight">\(2m\)</span> parameters; if these are chosen from a population <span class="math notranslate nohighlight">\(P\)</span>, then there are <span class="math notranslate nohighlight">\(p^{2m}\)</span> possible such matrices. If all of the <span class="math notranslate nohighlight">\(\alpha_j\)</span> are zero, or if all of the <span class="math notranslate nohighlight">\(\beta_j\)</span> are zero, this is just a Frobenius companion matrix.</p>
<p><strong>Thirteenth Activity</strong>: find an interesting population for doubly companion matrices and produce some nice density plots.  See if you can discover something previously unknown.</p>
</div>
<div class="section" id="o-other">
<h3>O. Other<a class="headerlink" href="#o-other" title="Permalink to this headline">¶</a></h3>
<ol class="simple">
<li><p>Checkerboard (one of our students made this structure up!)
2.<a class="reference external" href="https://en.wikipedia.org/wiki/Persymmetric_matrix">”persymmetric” are symmetric about the anti-diagonal</a>.
There are also <a class="reference external" href="https://en.wikipedia.org/wiki/Centrosymmetric_matrix">“centrosymmetric” matrices</a> and as of this time of writing, no-one has drawn any Bohemian pictures of those.</p></li>
<li><p>Cauchy matrices (see Chapter 22 of the Handbook of Linear Algebra)</p></li>
<li><p>Loewner matrices (likewise)</p></li>
<li><p>Jacobi matrices  (likewise)</p></li>
<li><p>Recursive (like the Mandelbrot matrices)</p></li>
<li><p>Invent your own!</p></li>
</ol>
</div>
</div>
<div class="section" id="choice-of-colours-and-colourizing-the-density-plots">
<h2>Choice of colours, and colourizing the density plots<a class="headerlink" href="#choice-of-colours-and-colourizing-the-density-plots" title="Permalink to this headline">¶</a></h2>
<p>We took a long time to figure out a reasonable way to colourize the density plots.  We clearly wanted (and still want) “hotter” colours to represent higher density, and so that means some kind of monotonically-increasing colour function or map. We use ‘viridis’ and ‘plasma’ because they are <a class="reference external" href="https://matplotlib.org/stable/tutorials/colors/colormaps.html">perceptually even</a>. There are some great videos at that link (or pointed to by that link) which talk about creating a perceptually even colour scheme; and similarly about robustness under various kinds of colour blindness.  In the end, we settled on a scheme that tried to weight the colours also with the <em>area</em> covered at a particular density.  That is, we counted all the pixels with a count of (say) 5 eigenvalues in each pixel and we used that information to help map into the colour scheme.  Specifically, this is for the option we call “cumulative”, because it uses a cumulative frequency count to ensure monotonicity, and also to <em>attempt</em> to even out the <em>areas</em> of the figure that have any given range of colour.  Some of the results are quite pleasing (to our eyes) but you may very well wish to experiment with other colour functions.</p>
<p>There are a <em>lot</em> of possible professional visualization techniques that you could use, as well (for example, something called “splatting with a triangular kernel”).  Go for your life!  We’re going to stick with the simplest things, and fiddle with the resolutions to get the effects we want.  We get some quite nice pictures this way.</p>
<p>We call this one “van Gogh Mountains”, because it reminds us (a bit, anyway) of <a class="reference external" href="https://en.wikipedia.org/wiki/The_Starry_Night">The Starry Night</a>.</p>
<div class="figure align-default" id="vangoghmountains">
<a class="reference internal image-reference" href="../_images/vanGoghMountains.png"><img alt="../_images/vanGoghMountains.png" src="../_images/vanGoghMountains.png" style="height: 300px;" /></a>
<p class="caption"><span class="caption-number">Fig. 7 </span><span class="caption-text">van Gogh Mountains</span><a class="headerlink" href="#vangoghmountains" title="Permalink to this image">¶</a></p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># We now read in a saved set of characteristic polynomials, so we can work with it. </span>
<span class="n">mdim</span><span class="o">=</span><span class="mi">5</span> 
<span class="n">A</span> <span class="o">=</span> <span class="n">Symmetric</span><span class="p">(</span><span class="n">mdim</span><span class="p">)</span>
<span class="n">pcode</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span> <span class="c1"># This is -1, i, and -i</span>
<span class="n">poplabel</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pcode</span><span class="p">])</span>
<span class="n">population</span> <span class="o">=</span> <span class="p">[</span><span class="n">populationlist</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pcode</span><span class="p">]</span>
<span class="n">sequencelength</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">getNumberOfMatrixEntries</span><span class="p">()</span>
<span class="n">numberpossible</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">)</span><span class="o">**</span><span class="n">sequencelength</span>
<span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;../Supplementary Material/Bohemian/symmetric/exhaustivecharpolys_pop_</span><span class="si">{}</span><span class="s1">_m</span><span class="si">{}</span><span class="s1">_N</span><span class="si">{}</span><span class="s1">.json&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">poplabel</span><span class="p">,</span><span class="n">mdim</span><span class="p">,</span><span class="n">numberpossible</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span> <span class="n">fname</span> <span class="p">)</span>
<span class="n">in_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
<span class="n">saved_charpolys</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">in_file</span><span class="p">)</span>
<span class="n">in_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">charpoly_tuple_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">k</span><span class="p">):</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">saved_charpolys</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

<span class="c1"># Compute the roots, this time without worrying about copies</span>
<span class="n">kis</span> <span class="o">=</span> <span class="n">charpoly_tuple_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="n">N</span> <span class="o">=</span> <span class="n">mdim</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">kis</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;Number of polynomials (not counting copies) is </span><span class="si">{}</span><span class="s2"> so the number of roots is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">kis</span><span class="p">),</span><span class="n">N</span><span class="p">)</span> <span class="p">)</span>
<span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;The number of matrices is </span><span class="si">{}</span><span class="s2"> so the number of eigenvalues is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">numberpossible</span><span class="p">,</span><span class="n">mdim</span><span class="o">*</span><span class="n">numberpossible</span><span class="p">))</span>
<span class="n">rtvec</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">residuals</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">singulars</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">nilpotents</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="k">for</span> <span class="n">ptuple</span> <span class="ow">in</span> <span class="n">kis</span><span class="p">:</span>
    <span class="n">pol</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ptuple</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">ptuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">singulars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pol</span><span class="p">)</span>
    <span class="n">trail</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ptuple</span><span class="p">[:</span><span class="mi">5</span><span class="p">])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">trail</span><span class="p">):</span>
        <span class="n">nilpotents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ptuple</span><span class="p">)</span>
    <span class="n">rts</span> <span class="o">=</span> <span class="n">pol</span><span class="o">.</span><span class="n">roots</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mdim</span><span class="p">):</span>
        <span class="n">rtvec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">rts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">)</span>
        <span class="n">residuals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">pol</span><span class="p">(</span><span class="n">rts</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">)</span> <span class="c1"># Compute the polynomial at all the putative roots</span>
<span class="n">finish</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Took &quot;</span><span class="p">,</span> <span class="n">finish</span><span class="o">-</span><span class="n">start</span><span class="p">,</span> <span class="s2">&quot; seconds to find all </span><span class="si">{}</span><span class="s2"> of the roots&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rtvec</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;There are &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">singulars</span><span class="p">),</span> <span class="s2">&quot;characteristic polynomials with zero as a root&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;There are &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nilpotents</span><span class="p">),</span> <span class="s2">&quot;Characteristic polynomials with quadruple zero roots&quot;</span><span class="p">,</span> <span class="n">nilpotents</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>../Supplementary Material/Bohemian/symmetric/exhaustivecharpolys_pop_5_3_7_m5_N14348907.json
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Number of polynomials (not counting copies) is 75415 so the number of roots is 377075
The number of matrices is 14348907 so the number of eigenvalues is 71744535
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Took  8.579744338989258  seconds to find all 377075 of the roots
There are  7575 characteristic polynomials with zero as a root
There are  0 Characteristic polynomials with quadruple zero roots []
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">real</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">rtvec</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">imag</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">rtvec</span><span class="p">]</span>
<span class="n">eigplot</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="o">-</span><span class="n">mdim</span><span class="p">,</span><span class="n">mdim</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="n">mdim</span><span class="p">,</span><span class="n">mdim</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/bohemian-matrices_83_0.png" src="../_images/bohemian-matrices_83_0.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">nrow</span> <span class="o">=</span> <span class="mi">800</span>
<span class="n">ncol</span> <span class="o">=</span> <span class="mi">800</span>
<span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="c1">#[-mdim,mdim,-mdim,mdim]</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">DensityPlot</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span><span class="p">)</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="k">for</span> <span class="n">ptuple</span> <span class="ow">in</span> <span class="n">kis</span><span class="p">:</span>
    <span class="n">pol</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ptuple</span><span class="p">])</span>
    <span class="n">rts</span> <span class="o">=</span> <span class="n">pol</span><span class="o">.</span><span class="n">roots</span><span class="p">()</span>
    <span class="n">image</span><span class="o">.</span><span class="n">addMultiplePoints</span><span class="p">(</span><span class="n">rts</span><span class="p">,</span> <span class="n">charpoly_tuple_dict</span><span class="p">[</span><span class="n">ptuple</span><span class="p">])</span>
<span class="n">finish</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Took &quot;</span><span class="p">,</span> <span class="n">finish</span><span class="o">-</span><span class="n">start</span><span class="p">,</span> <span class="s2">&quot; seconds to recompute and make a density plot of the roots (including copies)&quot;</span> <span class="p">)</span>
<span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;viridis&#39;</span>
<span class="n">image</span><span class="o">.</span><span class="n">makeDensityPlot</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;../Supplementary Material/Bohemian/symmetric/p_</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">whole_</span><span class="si">{}</span><span class="s1">N</span><span class="si">{}</span><span class="s1">.png&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">poplabel</span><span class="p">,</span><span class="n">cmap</span><span class="p">,</span><span class="n">mdim</span><span class="p">,</span><span class="n">numberpossible</span><span class="p">),</span> 
                      <span class="n">bgcolor</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">colorscale</span><span class="o">=</span><span class="s2">&quot;cumulative&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Took  5.745038270950317  seconds to recompute and make a density plot of the roots (including copies)
</pre></div>
</div>
<img alt="../_images/bohemian-matrices_84_1.png" src="../_images/bohemian-matrices_84_1.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mx</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">residuals</span><span class="p">:</span>
    <span class="n">mx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">mx</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">)</span>  <span class="c1"># If the roots were exactly right, these would all be zero</span>

<span class="c1"># A small maximum residual is acceptable; it is essentially a measure</span>
<span class="c1"># of the effect of rounding error.  Numerical analysts point out this is not</span>
<span class="c1"># the whole story!  One also needs the theory of &quot;condition numbers.&quot; We save that </span>
<span class="c1"># for another day.</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Maximum residual is &quot;</span><span class="p">,</span> <span class="n">mx</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Maximum residual is  5.6745130712598915e-12
</pre></div>
</div>
</div>
</div>
<p>How many <em>stable</em> matrices are there? There are two kinds of “stable” matrices: one with all eigenvalues in the left-half plane <span class="math notranslate nohighlight">\(\Re(\lambda) &lt; 0\)</span> and another with all eigenvalues inside the unit disk, <span class="math notranslate nohighlight">\(|\lambda| &lt; 1\)</span>.  The first is important for differential equations like <span class="math notranslate nohighlight">\(\dot y(t) = \mathbf{A} y(t)\)</span> and the second is important for difference equations (recurrence equations) such as <span class="math notranslate nohighlight">\(y_{k+1} = \mathbf{A} y_k\)</span>.  It is an interesting exercise to select out stable matrices.  It turns out that for symmetric matrices with population <span class="math notranslate nohighlight">\(-1\pm i\)</span>, <em>all</em> of the matrices have eigenvalues in <span class="math notranslate nohighlight">\(\Re(\lambda)\le 0\)</span> so they are all at least “neutrally” stable.  To prove this, we had to learn a theorem new to us, the Bendixon–Bromwich–Hirsch theorem, from the early 1900s (the first paper was published in 1902).  We won’t give the details here.  In contrast to the symmetric case with population <span class="math notranslate nohighlight">\(-1\pm i\)</span> (which we plot below and you can see have <span class="math notranslate nohighlight">\(\Re(\lambda)\le 0\)</span>), for the <em>big</em> file just loaded in and plotted above (for population <span class="math notranslate nohighlight">\((\pm i, 1)\)</span>), many of the polynomials have roots in the right half plane.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Nsample</span> <span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="mi">4</span> <span class="c1">#10**4  # Took 4 and a bit hours for (m=7 and nsample = 15*10**7)</span>
<span class="c1"># 5 hours and ten minutes m=8 nsample=1.5e8 (integer form)</span>
<span class="n">mdim</span> <span class="o">=</span> <span class="mi">7</span> <span class="c1"># has 268 million matrices</span>
<span class="c1">#mdim = 8 # has 68 billion matrices</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">Symmetric</span><span class="p">(</span><span class="n">mdim</span><span class="p">)</span>
<span class="n">pcode</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="n">population</span> <span class="o">=</span> <span class="p">[</span><span class="n">populationlist</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pcode</span><span class="p">]</span>
<span class="n">sequencelength</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">getNumberOfMatrixEntries</span><span class="p">()</span>
<span class="n">numberpossible</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">)</span><span class="o">**</span><span class="n">sequencelength</span>
<span class="nb">print</span><span class="p">(</span> <span class="n">sequencelength</span><span class="p">,</span> <span class="n">numberpossible</span> <span class="p">)</span>
<span class="c1"># Make this reproducible, for testing purposes: choose a seed</span>
<span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span> <span class="mi">21713</span> <span class="p">)</span>

<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">mdim</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">mdim</span><span class="p">,</span> <span class="n">mdim</span><span class="p">]</span>
<span class="n">nrow</span> <span class="o">=</span> <span class="mi">1200</span>
<span class="n">ncol</span> <span class="o">=</span> <span class="mi">600</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">DensityPlot</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span><span class="p">)</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nsample</span><span class="p">):</span>
    <span class="n">A</span><span class="o">.</span><span class="n">makeMatrix</span><span class="p">([</span> <span class="n">population</span><span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">))]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sequencelength</span><span class="p">)])</span>
    <span class="n">image</span><span class="o">.</span><span class="n">addPoints</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">eig</span><span class="p">())</span>

<span class="n">poplabel</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pcode</span><span class="p">])</span>
<span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;viridis&#39;</span>
<span class="n">image</span><span class="o">.</span><span class="n">makeDensityPlot</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;../Supplementary Material/Bohemian/symmetric/p_</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">whole_</span><span class="si">{}</span><span class="s1">N</span><span class="si">{}</span><span class="s1">.png&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">poplabel</span><span class="p">,</span><span class="n">cmap</span><span class="p">,</span><span class="n">mdim</span><span class="p">,</span><span class="n">Nsample</span><span class="p">),</span> <span class="n">bgcolor</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">colorscale</span><span class="o">=</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
<span class="n">finish</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Took </span><span class="si">{}</span><span class="s2"> seconds to compute and plot &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">finish</span><span class="o">-</span><span class="n">start</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>28 268435456
</pre></div>
</div>
<img alt="../_images/bohemian-matrices_87_1.png" src="../_images/bohemian-matrices_87_1.png" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Took 5.151955604553223 seconds to compute and plot 
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="discussion-topics">
<h2>Discussion topics<a class="headerlink" href="#discussion-topics" title="Permalink to this headline">¶</a></h2>
<p>Here are some questions for discussion (most of which we can’t answer, or have only partial answers for).</p>
<p>First, there are the “exclusion zones,” the “holes” in the pictures where there are no eigenvalues. Some of the holes look starlike.  Can you explain these?  There is the very interesting paper by Edmund Harriss, Katherine Stange, and Steve Trettel called <a class="reference external" href="https://arxiv.org/abs/2008.07655">Algebraic Number Starscapes</a>, which has a kind of number-theoretic explanation.  Rather deep material, though!  More papers are being written on this, using Galois theory too.</p>
<p>Peter Borwein and Chris Pinner had already explained a similar gap for “Littlewood polynomials”, that is polynomials with coefficients from <span class="math notranslate nohighlight">\(\mathbb{P} = \mathbb{L} := \{-1, 1\}\)</span>. They also have explained the larger gap between <span class="math notranslate nohighlight">\(0\)</span> and the nearest non-real root. The topic/question for discussion here is more “what does it mean to explain this?” In some sense these pictures just <em>are</em>. In another sense there’s an idea of “fairness” or “balance” at work. The eigenvalues must lie in the union of three disks each of radius 4 centered at <span class="math notranslate nohighlight">\(-1\)</span>, <span class="math notranslate nohighlight">\(0\)</span>, and <span class="math notranslate nohighlight">\(1\)</span> by the <strong><a class="reference external" href="https://en.wikipedia.org/wiki/Gershgorin_circle_theorem">Gershgorin circle theorem</a></strong>; and since there’s a finite number of eigenvalues, there must be holes and gaps between any two eigenvalues that are not exactly equal.
If a Bohemian eigenvalue is going to be “close” to zero, then like a “snap-to” guide on a computer the eigenvalue will actually <em>be</em> zero.</p>
<p>Why is there a visible pattern to the holes? Part of the explanation lies in the symmetry of the Gershgorin disks: each hole will have two “parts” or “reflections” either to the left of the right. Then there is the puzzling shape of the exclusion zone around all the eigenvalues. For case A, it’s the outside of a slightly flattened oval (restricting the matrices further to those with trace zero —that is the sum of the diagonal elements—might “unflatten” the oval: why don’t you try? Let us know what the picture looks like). This is not <em>too</em> surprising.</p>
<p>But for upper Hessenberg Toeplitz, with zero diagonal, we get a decided lozenge. Why the angular shape? Does it persist as the dimension <span class="math notranslate nohighlight">\(n \to \infty\)</span>? We have now solved this one!  We used properties of large-dimension Toeplitz matrices (and the turbocharged Gerschgorin theorem) for this.</p>
<p>For the skew-symmetric case, we used the Bendixon—Bromwich—Hirsch Theorem mentioned above to explain the “square” and “diamond” shapes.  We just now solved both these puzzles (this week and last week, as this is being written). The paper describing these two solutions is still being written (by the time this gets through its own review and publication process, we <em>might</em> be able to give a reference.</p>
<p>But most of the other puzzles remain.</p>
<p>It’s all a bit frustrating. (Welcome to the world of mathematical research. The puzzles here can be arbitrarily difficult.)</p>
<p>We do <em>not</em> have any explanation (yet) for the diffraction patterns.  The best we can do is that the apparent curves are really what the human eye sees when curves <em>stop</em>; we’re looking at the edges of other curves.  This is part of the “Algebraic Number Starscapes” theory, we think.  We don’t really understand that theory.</p>
<p>But there are other things to discover, too.  Your job just now is discovery; explanation can wait.</p>
<div class="section" id="the-influence-of-population">
<h3>The influence of population<a class="headerlink" href="#the-influence-of-population" title="Permalink to this headline">¶</a></h3>
<p>If we replaced <span class="math notranslate nohighlight">\(\mathbb{P} = \{-1, 0, 1\}\)</span> with <span class="math notranslate nohighlight">\(\{-2, 0, 2\}\)</span> all that would happen is that <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> would be replaced by <span class="math notranslate nohighlight">\(2\mathbf{A}\)</span>. It is obvious after the fact that if <span class="math notranslate nohighlight">\(\mathbf{A}\overrightarrow{x} = \lambda\overrightarrow{x}\)</span> so <span class="math notranslate nohighlight">\(\lambda\)</span> is an eigenvalue of <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>, then <span class="math notranslate nohighlight">\(2A\overrightarrow{x} = 2\lambda\overrightarrow{x}\)</span> so <span class="math notranslate nohighlight">\(2\lambda\)</span> is an eigenvalue of <span class="math notranslate nohighlight">\(2\mathbf{A}\)</span>. Similarly eigenvalues for the population <span class="math notranslate nohighlight">\(\{-2, -1, 0, 1, 2\}\)</span> will be twice the eigenvalues for <span class="math notranslate nohighlight">\(\{-1, -\frac{1}{2}, 0, \frac{1}{2}, 1\}\)</span>.</p>
<p>Similarly, the population <span class="math notranslate nohighlight">\(\{-i, 0, i\}\)</span> will merely give eigenvalues <span class="math notranslate nohighlight">\(i\lambda\)</span> if <span class="math notranslate nohighlight">\(\lambda\)</span> comes from the population <span class="math notranslate nohighlight">\(\{-1, 0, 1\}\)</span>; that is, they’ll be rotated 90 degrees. Shifts (translations) are not so easy. The eigenvalues from <span class="math notranslate nohighlight">\(\{0, 1, 2\}\)</span> are quite different to those of <span class="math notranslate nohighlight">\(\{-1, 0, 1\}\)</span> even though each matrix in the Bohemian family for <span class="math notranslate nohighlight">\(\{0, 1, 2\}\)</span> corresponds exactly to a matrix from the family <span class="math notranslate nohighlight">\(\{-1, 0, 1\}\)</span> (just subtract the matrix that is all <span class="math notranslate nohighlight">\(1\)</span>s).</p>
<p><strong>Fourteenth Activity:</strong> Some populations that we have looked at are <span class="math notranslate nohighlight">\(\mathbb{P} = \{-1, 0, 1\}\)</span>, <span class="math notranslate nohighlight">\(\{0, 1\}\)</span>, <span class="math notranslate nohighlight">\(\{-1, 1\}\)</span>, <span class="math notranslate nohighlight">\(\{-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5\}\)</span>, <span class="math notranslate nohighlight">\(\{-1, -\frac{1}{1000}, 0, \frac{1}{1000}, 1\}\)</span>, and <span class="math notranslate nohighlight">\(\{0, \{\pm F_{k}\}_{k=1}^{m}\}\)</span> for <span class="math notranslate nohighlight">\(F_{k}\)</span> being Fibonacci numbers: <span class="math notranslate nohighlight">\(F_{0}\)</span>, <span class="math notranslate nohighlight">\(F_{1} = 1\)</span>, <span class="math notranslate nohighlight">\(F_{k+1} = F_{k} + F_{k-1}\)</span>; see the <a class="reference external" href="http://www.bohemianmatrices.com/gallery/Fibonacci_5x5/">beautiful eigenvalue picture originally by Venkataraman Balasubramanian</a>. Choose your own populations, make your own pictures: surprise us, and name your creations.</p>
</div>
</div>
<div class="section" id="applications">
<h2>Applications<a class="headerlink" href="#applications" title="Permalink to this headline">¶</a></h2>
<p>These are rather fun games to play (the puzzles are too hard, though, we think). But what’s it all for?</p>
<p>The matrices populated <span class="math notranslate nohighlight">\(\{-1, 1\}\)</span> are called Bernoulli matrices and these are used in compressed sensing, which is a way to recover exact signals sent over lossy channel(s). The population <span class="math notranslate nohighlight">\(\{0, 1\}\)</span> includes graph incidence matrices, which have innumerable applications (literally billions of dollars are saved every year by graph theoretic means). The matrices populated by <span class="math notranslate nohighlight">\(\{-1, 0, 1\}\)</span> are examples of what are called “sign pattern matrices” which are used in mathematical biology. Nick Higham has used them to establish new lower bounds in open problems in computational linear algebra.</p>
<p>For their own reasons, Fields medallist Terence Tao and his co-worker Van Vu have studied the asymptotic distribution of eigenvalues of general matrices (case A) with populations <span class="math notranslate nohighlight">\(\{-k, -k+1, \ldots, -1, 0, 1, 2, \ldots, k\}\)</span>.</p>
<p>We were originally motivated simply by looking for good test problems for eigenvalue software (and polynomial rootfinding software). Indeed, we have found important bugs this way. But now the question uppermost on our minds is, what does it mean to be random, and what is the influence of nonlinearity? By sheer brute force, we may enumerate all possible eigenvalues (if the dimension is small enough) and we have a chance to understand the influence of structure (of the matrices) and of the population.</p>
<p>We are very excited about this project. Your contributions are very welcome.</p>
</div>
<div class="section" id="exercises-for-the-bohemian-matrix-unit">
<h2>Exercises for the Bohemian Matrix Unit<a class="headerlink" href="#exercises-for-the-bohemian-matrix-unit" title="Permalink to this headline">¶</a></h2>
<ol class="simple">
<li><p>Write down as many questions as you can for this unit.</p></li>
<li><p>Looking back at the Fractals Unit, there seem to be clear connections with this unit.  Discuss them.</p></li>
<li><p>Looking back at the Rootfinding Unit, there seem to be clear connections with this unit.  Discuss them.</p></li>
<li><p>Looking back at the Continued Fractions Unit, it seems a stretch to connect them.  Can you find a connection?</p></li>
</ol>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./Contents"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="fractals-and-julia-sets.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Fractals and Julia Sets</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="mandelbrot.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Mandelbrot Polynomials and Matrices</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By Neil J. Calkin, Eunice Y.S. Chan, and Robert M. Corless<br/>
    
        &copy; Copyright 2022.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>