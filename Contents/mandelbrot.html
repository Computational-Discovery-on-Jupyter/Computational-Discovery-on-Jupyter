
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Mandelbrot Polynomials and Matrices &#8212; Computational Discovery on Jupyter</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=62ba249389abaaa9ffc34bf36a076bdc1d65ee18" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=f31d14ad54b65d19161ba51d4ffff3a77ae00456"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="shortcut icon" href="../_static/logo.jpg"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Chaos Game Representation" href="chaos-game-representation.html" />
    <link rel="prev" title="Bounded Height Matrices of Integers (Bohemian Matrices)" href="bohemian-matrices.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.jpg" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Computational Discovery on Jupyter</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../index.html">
                    Welcome to Computational Discovery on Jupyter
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Preface
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../preamble.html">
   Preamble
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Installing-Python-and-Jupyter.html">
   Before we begin: installing Python and Jupyter
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Contents
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="Computing-with-Fibonacci.html">
   Computing with Fibonacci Numbers
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="continued-fractions.html">
   Continued Fractions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="rootfinding.html">
   Rootfinding, Newton’s Method, and Dynamical Systems
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="fractals-and-julia-sets.html">
   Fractals and Julia Sets
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="bohemian-matrices.html">
   Bounded Height Matrices of Integers (Bohemian Matrices)
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Mandelbrot Polynomials and Matrices
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="chaos-game-representation.html">
   Chaos Game Representation
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Epilogue
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../Looking-back.html">
   Zanshin
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Appendix
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../Appendix/What-to-do-when-things-go-wrong.html">
   What do to when things go wrong
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Appendix/floating-point.html">
   The Bare Minimum about Floating-Point
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Appendix/binomials-factorials-combinatorics.html">
   Binomials, Factorials, and other Combinatorial Things
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Appendix/complex-numbers.html">
   Complex Numbers
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Appendix/symbolic-computation.html">
   Symbolic Computation: The Pitfalls
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Reports on Activities
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../Solutions/Reports%20on%20Fibonacci%20Activities.html">
   Reports on Fibonacci Activities
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Solutions/Reports%20on%20Continued%20Fractions%20Activities.html">
   Reports on Continued Fractions Activities
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Solutions/Reports%20on%20Rootfinding%20Activities.html">
   Reports on Rootfinding Activities
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Solutions/Reports%20on%20Julia%20Set%20Activities.html">
   Reports on Julia Set Activities
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Solutions/Reports%20on%20Bohemian%20Activities.html">
   Reports on Bohemian activities
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Solutions/Reports%20on%20Mandelbrot%20Activities.html">
   Reports on Mandelbrot Activities
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../Solutions/Reports%20on%20Chaos%20Game%20Activities.html">
   Reports on Chaos Game Activities
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Back Matter
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../acknowledgements.html">
   Acknowledgements
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../about.html">
   About the authors
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../references.html">
   References
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/Computational-Discovery-on-Jupyter/Computational-Discovery-on-Jupyter"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/Computational-Discovery-on-Jupyter/Computational-Discovery-on-Jupyter/edit/master/book/Contents/mandelbrot.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Edit this page"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="headerbtn__text-container">suggest edit</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/Contents/mandelbrot.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-note-to-the-student-reader">
   A note to the student/reader
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-note-to-the-instructor">
   A note to the Instructor
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-mandelbrot-set-and-mandelbrot-polynomials">
   The Mandelbrot Set and Mandelbrot Polynomials
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#back-to-mandelbrot-iteration-with-a-symbolic-c">
     Back to Mandelbrot iteration with a symbolic c
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#some-activities-with-mandelbrot-polynomials-with-a-more-mathematical-flavour">
   Some Activities with Mandelbrot polynomials with a more mathematical flavour
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#programming-mandelbrot-polynomial-iterations">
   Programming Mandelbrot polynomial iterations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#eigenvalues-and-roots-of-polynomials">
   Eigenvalues and roots of polynomials
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#but-wait-that-s-backwards">
     But wait, that’s backwards!
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#mandelbrot-matrices">
   Mandelbrot matrices
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#looking-back-at-the-programming-constructs-used-in-this-unit">
   Looking back at the programming constructs used in this unit
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#more-mandelbrot-activities">
   More Mandelbrot Activities
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Mandelbrot Polynomials and Matrices</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-note-to-the-student-reader">
   A note to the student/reader
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-note-to-the-instructor">
   A note to the Instructor
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-mandelbrot-set-and-mandelbrot-polynomials">
   The Mandelbrot Set and Mandelbrot Polynomials
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#back-to-mandelbrot-iteration-with-a-symbolic-c">
     Back to Mandelbrot iteration with a symbolic c
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#some-activities-with-mandelbrot-polynomials-with-a-more-mathematical-flavour">
   Some Activities with Mandelbrot polynomials with a more mathematical flavour
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#programming-mandelbrot-polynomial-iterations">
   Programming Mandelbrot polynomial iterations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#eigenvalues-and-roots-of-polynomials">
   Eigenvalues and roots of polynomials
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#but-wait-that-s-backwards">
     But wait, that’s backwards!
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#mandelbrot-matrices">
   Mandelbrot matrices
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#looking-back-at-the-programming-constructs-used-in-this-unit">
   Looking back at the programming constructs used in this unit
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#more-mandelbrot-activities">
   More Mandelbrot Activities
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="mandelbrot-polynomials-and-matrices">
<h1>Mandelbrot Polynomials and Matrices<a class="headerlink" href="#mandelbrot-polynomials-and-matrices" title="Permalink to this headline">#</a></h1>
<a class="reference internal image-reference" href="../_images/explosion32comp.gif"><img alt="Exploding Mandelbrot 32" class="align-center" src="../_images/explosion32comp.gif" style="height: 400px;" /></a>
<section id="a-note-to-the-student-reader">
<h2>A note to the student/reader<a class="headerlink" href="#a-note-to-the-student-reader" title="Permalink to this headline">#</a></h2>
<p>This unit uses some ideas of the late <a class="reference external" href="https://en.wikipedia.org/wiki/Benoit_Mandelbrot">Benoit Mandelbrot</a> and some known facts about the so-called <em>Mandelbrot Set</em>, together with some of our own ideas, to help you to learn the following:</p>
<ol class="simple">
<li><p>A bit more Python programming, including more practice with the use of <em>numerical libraries</em> from NumPy, <em>iteration</em> and <em>recursion</em>; some new things, such as <em>loop invariants</em>, <em>automatic differentiation</em>, <em>symbolic computation</em>, and a bit more about graphics.</p></li>
<li><p>A bit more about polynomials: the <em>cubic formula</em> (we won’t need the quartic formula, and even our use of the cubic formula is a bit contrived; but we think it’s fun), the <em>cost of numerical solution of polynomials</em> (we will point you to the current numerical champion polynomial solver, <a class="reference external" href="https://en.wikipedia.org/wiki/MPSolve">MPSolve</a>), and the rather necessary-to-know notions of <em>numerical stability</em> and <em>conditioning</em>.  Most of these topics are not taught as thoroughly as they should be, in one’s first numerical analysis course; so this material here should strengthen the results when you do encounter them.</p></li>
<li><p>The surprising use of <em>eigenvalues</em> to find roots of polynomials.  The first treatment of eigenvalues (typically in a Linear Algebra course, even though the problem is not, strictly speaking, linear) usually runs the other way around, and defines the eigenvalues of a matrix in terms of the <em>characteristic polynomial</em> of the matrix. Indeed, we will teach you a concept not in the textbooks: namely, the concept of a <em>minimal height companion matrix</em> and we will show you one such for the Mandelbrot polynomials.</p></li>
<li><p>A bit more about <em>dynamical systems</em>, especially about <em>iteration</em> and <em>composition</em>.</p></li>
<li><p>An excellent approximate formula for the <em>largest magnitude root</em> of the Mandelbrot polynomial.</p></li>
<li><p>An honest-to-goodness analytic solution to the Mandelbrot iteration (this is a very new result, published only in 2021), valid for all <span class="math notranslate nohighlight">\(c\)</span> <em>outside</em> the Mandelbrot set.</p></li>
<li><p>That we don’t know everything about Mandelbrot polynomials and matrices, and that you might be able to answer some open questions.</p></li>
</ol>
</section>
<section id="a-note-to-the-instructor">
<h2>A note to the Instructor<a class="headerlink" href="#a-note-to-the-instructor" title="Permalink to this headline">#</a></h2>
<p>The students tend to really like this unit.  Mandelbrot wrote so well that it is quite possible to ask students to read his papers (especially his math education papers).  Read them yourself, if you haven’t already.</p>
<p>We have put some of our own research into this unit.  We believe that the results we have included are accessible (and of course we believe that they are interesting).  There are some open problems here that we believe some students (or you!) may be able to close for us.  At the time of writing, the most itching one is whether or not the Mandelbrot polynomials are unimodal.  This seems like it ought to be easy, but we couldn’t do it.</p>
<p>The notion of iteration (discrete dynamical system) is not, apparently, of interest to every mathematician.  But it is an extremely powerful idea for computation, and there are many open mathematical problems associated with it.  And it is natural to introduce in a computational context.</p>
<p>Rounding errors don’t play a terribly large role in this unit, although they do push us to eigenvalue methods and away from polynomials that have large coefficients.  This may be problematic for some students to grasp.</p>
</section>
<section id="the-mandelbrot-set-and-mandelbrot-polynomials">
<h2>The Mandelbrot Set and Mandelbrot Polynomials<a class="headerlink" href="#the-mandelbrot-set-and-mandelbrot-polynomials" title="Permalink to this headline">#</a></h2>
<p>The <a class="reference external" href="https://en.wikipedia.org/wiki/Mandelbrot_set">Wikipedia article on the Mandelbrot Set</a> is pretty comprehensive, and readable. We’ll sum up the definition here, and try to flesh it out a bit.  The definition is based on the following, apparently very simple, function:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
f(z) = z^2 + c 
\end{equation*}\]</div>
<p>This is apparently only a simple quadratic in <span class="math notranslate nohighlight">\(z\)</span>, and depends linearly on the constant <span class="math notranslate nohighlight">\(c\)</span>.  We now consider <em>what happens when we repeatedly apply this function</em>, starting at 0 (an apparently simple point).  That is, put</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
z_0 = 0
\end{equation*}\]</div>
<p>and then define <span class="math notranslate nohighlight">\(z_k\)</span> for <span class="math notranslate nohighlight">\(k=1\)</span>, <span class="math notranslate nohighlight">\(k=2\)</span>, <span class="math notranslate nohighlight">\(k=3\)</span>, and so on in turn by the iterative formula (or recursive formula, or <em>dynamical</em> formula)</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
z_{n+1} = f(z_n) = z_n^2 + c .
\end{equation*}\]</div>
<p>This gives us <span class="math notranslate nohighlight">\(z_1 = z_0^2 + c = 0^2 + c = c\)</span>, and then subsequently <span class="math notranslate nohighlight">\(z_2 = z_1^2 + c = c^2 + c\)</span>, and then <span class="math notranslate nohighlight">\(z_3 = (c^2+c)^2 + c = c^4 + 2c^3 + c^2 + c\)</span>, and so on.</p>
<div class="admonition-pass-the-parcel-again admonition">
<p class="admonition-title">Pass the parcel, again</p>
<p>In this unit one could play “Pass the Parcel” again in class, with the initiator choosing the the value of <span class="math notranslate nohighlight">\(c\)</span> and starting with <span class="math notranslate nohighlight">\(z_0 = 0\)</span> so <span class="math notranslate nohighlight">\(z_1 = c\)</span>.  Passing each successive <span class="math notranslate nohighlight">\(z_k\)</span> on to the next person to compute <span class="math notranslate nohighlight">\(z_{k+1}\)</span> makes the connection with the activity from Continued Fractions.  Indeed, that game could be played with Newton iteration or Halley iteration for rootfinding, and for the iterations used in the Fractals unit.  It’s a bit harder to find a “pass the parcel” game for Bohemian matrices but it could be done, if you wanted.  In the next unit, on the Chaos Game Representation, there is a better game to play, but it is obviously related to this one.</p>
</div>
<p>Several important things are going on here: this looks simple, and in one sense it is, but we will see some surprising things from this.  This is an example of a <em>nonlinear dynamical system</em> (perhaps the “most famous” example of a nonlinear dynamical system).  We are repeatedly composing the function <span class="math notranslate nohighlight">\(f(z) = z^2+c\)</span> with itself: <span class="math notranslate nohighlight">\(z_2 = f(c)\)</span> and <span class="math notranslate nohighlight">\(z_3 = f(f(c))\)</span> and <span class="math notranslate nohighlight">\(z_4 = f(f(f(c))\)</span>. Sometimes repeated composition is written with a power in brackets: <span class="math notranslate nohighlight">\(f^{(n)}(c)\)</span> means <span class="math notranslate nohighlight">\(f(f(f(\cdots(f(c))\cdots)))\)</span> where there are <span class="math notranslate nohighlight">\(n\)</span> copies of <span class="math notranslate nohighlight">\(f\)</span> used; this is where the pernicious notation <span class="math notranslate nohighlight">\(f^{(-1)}(c)\)</span> comes from, by the way. We will try to avoid this confusing notation.  Several things can be deduced about repeated composition.  For instance, the result of composing two polynomials together is another polynomial.  If <span class="math notranslate nohighlight">\(f(c)\)</span> is of degree <span class="math notranslate nohighlight">\(m\)</span> and <span class="math notranslate nohighlight">\(g(c)\)</span> is of degree <span class="math notranslate nohighlight">\(n\)</span> then <span class="math notranslate nohighlight">\(f(g(c))\)</span> is of degree <span class="math notranslate nohighlight">\(mn\)</span>, and so is <span class="math notranslate nohighlight">\(g(f(c))\)</span>.  If we were working with non-polynomials then we would also have to worry about matching up the domains and ranges, but polynomials are great because they always give a finite result output for any finite value input, and so composition always works.</p>
<p>We have written <span class="math notranslate nohighlight">\(z_3\)</span> out above as an explicit degree <span class="math notranslate nohighlight">\(4\)</span> polynomial (in the variable <span class="math notranslate nohighlight">\(c\)</span>), but if we actually want to compute a numerical value of <span class="math notranslate nohighlight">\(z_3\)</span> given a numerical value for <span class="math notranslate nohighlight">\(c\)</span> (say, <span class="math notranslate nohighlight">\(c=-1.2\)</span>) then it turns out to be better in several ways to just use the iterative formula itself and not the explicit polynomial. This is true even though we could write that explicit polynomial somewhat more efficiently in what is known as <a class="reference external" href="https://en.wikipedia.org/wiki/Horner%27s_method">Horner form</a>: <span class="math notranslate nohighlight">\(z_3 = c\cdot(1 + c\cdot(1 + c\cdot(2 + c)))\)</span>, which can be evaluated using only three floating-point multiplications and three floating-point additions. Using the iterative formula directly, though, there is no work to compute <span class="math notranslate nohighlight">\(z_0\)</span>, there is no floating-point work to compute <span class="math notranslate nohighlight">\(z_1 = c\)</span>, there is one multiplication and one addition to compute <span class="math notranslate nohighlight">\(z_2\)</span>, and one more multiplication and one more addition to compute <span class="math notranslate nohighlight">\(z_3\)</span>, showing that <span class="math notranslate nohighlight">\(z_3\)</span> can be computed in only two “flops” instead of three.  Note: one “flop” is <em>defined to be</em> one floating-point multiplication (or division) together with one floating-point addition (or subtraction).  It’s not a fine-tuned measure; it was meant for use in older analyses of the cost of computation.  On modern architectures, the notion is not really all that helpful; but you can see here that no matter what, the cost is less if we use the iteration directly.  This advantage only increases as the iteration proceeds: to compute <span class="math notranslate nohighlight">\(z_4\)</span> you only need one more “flop,” i.e. <span class="math notranslate nohighlight">\(3\)</span> flops, whereas from its polynomial form you need <span class="math notranslate nohighlight">\(2^3 = 8\)</span> flops (even ignoring the work that has to be done simply to write the polynomial out).  For <span class="math notranslate nohighlight">\(z_{30}(c)\)</span> the iteration takes only 29 flops; but the explicit polynomial is degree <span class="math notranslate nohighlight">\(2^{29}\)</span> and would take <span class="math notranslate nohighlight">\(2^{29}\)</span> flops to evaluate (actually, it’s worse: we would have to use multiple precision to deal with the big integer coefficients).  Thus, somehow, the iteration has <em>compressed</em> a very high degree polynomial into a very efficient box.</p>
<div class="tip admonition" id="mandelbrotactivity-1">
<p class="admonition-title">Mandelbrot Activity 1</p>
<p>Read the Wikipedia entry on the Mandelbrot set, and the entry on Mandelbrot.  Mandelbrot’s <em>educational</em> books and papers are amazing, and amazingly clearly written.  If you don’t come back from this activity, well, at least you left going in a good direction.
<a class="reference internal" href="../Solutions/Reports%20on%20Mandelbrot%20Activities.html#mandelbrotactivityreport-1"><span class="std std-ref">[Our thoughts]</span></a></p>
</div>
<section id="back-to-mandelbrot-iteration-with-a-symbolic-c">
<h3>Back to Mandelbrot iteration with a symbolic c<a class="headerlink" href="#back-to-mandelbrot-iteration-with-a-symbolic-c" title="Permalink to this headline">#</a></h3>
<p>Another important thing to notice in the above is that by leaving <span class="math notranslate nohighlight">\(c\)</span> symbolic, we have turned Mandelbrot’s iteration formula (or recursion formula) into some kind of generator for certain polynomials.  These are called (naturally enough) <em>Mandelbrot polynomials</em>.  We list the first few here, or at least their coefficients.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.polynomial</span> <span class="kn">import</span> <span class="n">Polynomial</span> <span class="k">as</span> <span class="n">Poly</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">8</span>

<span class="n">z0</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">z0</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># We can do &quot;symbolic polynomial arithmetic&quot; just with these coefficient vectors in Python</span>
<span class="n">z1</span> <span class="o">=</span> <span class="n">z0</span><span class="o">*</span><span class="n">z0</span> <span class="o">+</span> <span class="n">c</span>
<span class="nb">print</span><span class="p">(</span><span class="n">z1</span><span class="p">)</span>
<span class="n">z2</span> <span class="o">=</span> <span class="n">z1</span><span class="o">*</span><span class="n">z1</span> <span class="o">+</span> <span class="n">c</span>
<span class="nb">print</span><span class="p">(</span><span class="n">z2</span><span class="p">)</span>
<span class="n">z3</span> <span class="o">=</span> <span class="n">z2</span><span class="o">*</span><span class="n">z2</span> <span class="o">+</span> <span class="n">c</span>
<span class="nb">print</span><span class="p">(</span><span class="n">z3</span><span class="p">)</span>
<span class="n">z4</span> <span class="o">=</span> <span class="n">z3</span><span class="o">*</span><span class="n">z3</span> <span class="o">+</span> <span class="n">c</span>
<span class="nb">print</span><span class="p">(</span><span class="n">z4</span><span class="p">)</span>
<span class="n">z5</span> <span class="o">=</span> <span class="n">z4</span><span class="o">*</span><span class="n">z4</span> <span class="o">+</span> <span class="n">c</span>
<span class="nb">print</span><span class="p">(</span><span class="n">z5</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.0
0.0 + 1.0·x¹
0.0 + 1.0·x¹ + 1.0·x²
0.0 + 1.0·x¹ + 1.0·x² + 2.0·x³ + 1.0·x⁴
0.0 + 1.0·x¹ + 1.0·x² + 2.0·x³ + 5.0·x⁴ + 6.0·x⁵ + 6.0·x⁶ + 4.0·x⁷ +
1.0·x⁸
0.0 + 1.0·x¹ + 1.0·x² + 2.0·x³ + 5.0·x⁴ + 14.0·x⁵ + 26.0·x⁶ + 44.0·x⁷ +
69.0·x⁸ + 94.0·x⁹ + 114.0·x¹⁰ + 116.0·x¹¹ + 94.0·x¹² + 60.0·x¹³ +
28.0·x¹⁴ + 8.0·x¹⁵ + 1.0·x¹⁶
</pre></div>
</div>
</div>
</div>
<p>Translating that Python notation for polynomials back into something standard, we have</p>
<div class="amsmath math notranslate nohighlight" id="equation-8051c72b-5929-40f6-969b-af2f3628aeae">
<span class="eqno">(70)<a class="headerlink" href="#equation-8051c72b-5929-40f6-969b-af2f3628aeae" title="Permalink to this equation">#</a></span>\[\begin{align}
z_0 &amp;= 0 \\
z_1 &amp;= c \\
z_2 &amp;= c + c^2 \\
z_3 &amp;= c + c^2 + 2c^3 + c^4\\
z_4 &amp;= c + c^2 + 2c^3 + 5c^4 + 6c^5 + 6c^6 + 4c^7 + c^8 \\
z_5 &amp;= c + c^2 + 2c^3 + 5c^4 + 14c^5 + 26c^6 + 44c^7 + 69c^8 + 94c^9 + 114c^{10} + 116c^{11} + 94c^{12} + 60c^{13} + 28c^{14} + 8c^{15} + c^{16} 
\end{align}\]</div>
<p>The Mandelbrot set is <em>defined to be</em> the set of <span class="math notranslate nohighlight">\(c\)</span> for which this iteration remains bounded for all <span class="math notranslate nohighlight">\(n\)</span>: that is, everything <em>except</em> those values of <span class="math notranslate nohighlight">\(c\)</span> for which <span class="math notranslate nohighlight">\(|z_n| \to \infty\)</span>.  That’s a weird sort of definition, and you have to first reassure yourself that there really are values of <span class="math notranslate nohighlight">\(c\)</span> for which the <span class="math notranslate nohighlight">\(z_n\)</span> do <em>not</em> remain bounded.  Indeed, almost the first thing you would try was <span class="math notranslate nohighlight">\(c=1\)</span>: then <span class="math notranslate nohighlight">\(z_0 = 0\)</span>, <span class="math notranslate nohighlight">\(z_1 = 1\)</span>, <span class="math notranslate nohighlight">\(z_2 = 2\)</span>, <span class="math notranslate nohighlight">\(z_3 = 5\)</span>, <span class="math notranslate nohighlight">\(z_4 = 26\)</span>, and so on; each succeeding number is one more than the square of the previous, and this goes to infinity rapidly, in some sense.</p>
</section>
</section>
<section id="some-activities-with-mandelbrot-polynomials-with-a-more-mathematical-flavour">
<h2>Some Activities with Mandelbrot polynomials with a more mathematical flavour<a class="headerlink" href="#some-activities-with-mandelbrot-polynomials-with-a-more-mathematical-flavour" title="Permalink to this headline">#</a></h2>
<div class="tip admonition" id="mandelbrotactivity-2">
<p class="admonition-title">Mandelbrot Activity 2</p>
<p>Prove by induction that the degree of the <span class="math notranslate nohighlight">\(n\)</span>th Mandelbrot polynomial is <span class="math notranslate nohighlight">\(2^{n-1}\)</span>, and that the leading coefficient is <span class="math notranslate nohighlight">\(1\)</span>.
<a class="reference internal" href="../Solutions/Reports%20on%20Mandelbrot%20Activities.html#mandelbrotactivityreport-2"><span class="std std-ref">[Our proof]</span></a></p>
</div>
<div class="tip admonition" id="mandelbrotactivity-3">
<p class="admonition-title">Mandelbrot Activity 3</p>
<p>Prove that <span class="math notranslate nohighlight">\(c=-2\)</span> and <span class="math notranslate nohighlight">\(c=0\)</span> are both in the Mandelbrot set. Show that all zeros of Mandelbrot polynomials give <em>periodic orbits</em> under the Mandelbrot iteration and are thus in the Mandelbrot set.
<a class="reference internal" href="../Solutions/Reports%20on%20Mandelbrot%20Activities.html#mandelbrotactivityreport-3"><span class="std std-ref">[Our proofs]</span></a></p>
</div>
<div class="tip admonition" id="mandelbrotactivity-4">
<p class="admonition-title">Mandelbrot Activity 4</p>
<p>Is <span class="math notranslate nohighlight">\(i = \sqrt{-1}\)</span> in the Mandelbrot set?
<a class="reference internal" href="../Solutions/Reports%20on%20Mandelbrot%20Activities.html#mandelbrotactivityreport-4"><span class="std std-ref">[Yes]</span></a></p>
</div>
<div class="tip admonition" id="mandelbrotactivity-5">
<p class="admonition-title">Mandelbrot Activity 5</p>
<p>Prove that the Mandelbrot polynomials are <em>unimodal</em>.  At the time we write this, this question is open: solve it, and you could publish a paper with your proof (<a class="reference external" href="https://www.mapletransactions.org">Maple Transactions</a> would be a good place).  The word “unimodal” just means that the size of the coefficients increases to a peak, and then decays again.  As in <span class="math notranslate nohighlight">\(z_4\)</span>, the peak might be attained by two coefficients, not just one.  Seriously, we don’t know how to prove this.  We think it’s true, though.
<a class="reference internal" href="../Solutions/Reports%20on%20Mandelbrot%20Activities.html#mandelbrotactivityreport-5"><span class="std std-ref">[We’ve got nothing.]</span></a></p>
</div>
<div class="tip admonition" id="mandelbrotactivity-6">
<p class="admonition-title">Mandelbrot Activity 6</p>
<p>Solve <span class="math notranslate nohighlight">\(z_3 = 0\)</span> by hand, as follows.  First, divide out the visible root, <span class="math notranslate nohighlight">\(c=0\)</span>, to get the cubic equation <span class="math notranslate nohighlight">\(0 = 1 + c + 2c^2 + c^3\)</span>.  Then put <span class="math notranslate nohighlight">\(c = \xi - 2/3\)</span> so <span class="math notranslate nohighlight">\(c^3 = (\xi -2/3)^3 = \xi^3 - 2\xi^2 + 4\xi/9 - 8/27\)</span> which will transform the equation into a cubic in <span class="math notranslate nohighlight">\(\xi\)</span> of the form <span class="math notranslate nohighlight">\(0 = q + p\xi + \xi^3\)</span>.  Then put <span class="math notranslate nohighlight">\(\xi = u + v\)</span> (introducing two new variables seems like the opposite of progress, but trust us, it will help).  This transforms the equation to <span class="math notranslate nohighlight">\((u+v)^3 + p(u+v) + q = 0\)</span>, or <span class="math notranslate nohighlight">\(u^3 + 3uv(u+v) + p(u+v) + q = 0\)</span>.  Show that if you can find <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> that simultaneously solve <span class="math notranslate nohighlight">\(3uv + p = 0\)</span> and <span class="math notranslate nohighlight">\(u^3 + v^3 + q = 0\)</span> then you can solve the original equation.  Do so.  Your formula at the end should give you three, and only three, roots. Write out your answer explicitly, and compare it with (say) the answer from Wolfram Alpha.
<a class="reference internal" href="../Solutions/Reports%20on%20Mandelbrot%20Activities.html#mandelbrotactivityreport-6"><span class="std std-ref">[Our derivation]</span></a></p>
</div>
</section>
<section id="programming-mandelbrot-polynomial-iterations">
<h2>Programming Mandelbrot polynomial iterations<a class="headerlink" href="#programming-mandelbrot-polynomial-iterations" title="Permalink to this headline">#</a></h2>
<p>Let us write a short program to evaluate Mandelbrot polynomials of arbitrary order.  This code shows several features: how to define a procedure (function); how to set a type for a parameter (more of a hint than a requirement, sadly); the use of keyword arguments; and the use of comments.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># This short program will evaluate Mandelbrot polynomials at a given point,</span>
<span class="c1"># or else it will compute the coefficient vector of a Mandelbrot polynomial.</span>
<span class="c1"># Which it will do depends on the type of the argument &quot;c.&quot;</span>
<span class="k">def</span> <span class="nf">Mandelbrot</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">c</span> <span class="c1"># try to inherit the type of c</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="n">c</span>
    <span class="k">return</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>That code tries to force the variable <code class="docutils literal notranslate"><span class="pre">z</span></code> to have the same data type as <code class="docutils literal notranslate"><span class="pre">c</span></code> does, by multiplying 0 by <code class="docutils literal notranslate"><span class="pre">c</span></code> and storing that type of 0 in the variable <code class="docutils literal notranslate"><span class="pre">z</span></code>.  It’s probably not necessary, because the very first time the loop is executed <code class="docutils literal notranslate"><span class="pre">z</span></code> gets replaced by something involving <code class="docutils literal notranslate"><span class="pre">c</span></code>.  But, in the case <code class="docutils literal notranslate"><span class="pre">n==0</span></code> that loop won’t execute at all, and the value of <code class="docutils literal notranslate"><span class="pre">z</span></code> being returned will be 0.  Let’s see if that works.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">Mandelbrot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.0
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">Mandelbrot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Poly</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.0
</pre></div>
</div>
</div>
</div>
<p>Ok, so it doesn’t.  This is a bit disappointing.  However, it’s pretty harmless in this case, so we just leave the code as it is.  To be fair, deciding automatically what <em>type</em> of zero one should return is fairly difficult.  Is <span class="math notranslate nohighlight">\(0\)</span> different from <code class="docutils literal notranslate"><span class="pre">0.0</span> <span class="pre">+</span> <span class="pre">0.0j</span></code>?  How about a zero polynomial of grade 3, like <span class="math notranslate nohighlight">\(0 + 0x + 0x^2 + 0x^3\)</span>?  Or a five hundred by five hundred matrix of zeros?  The data type of computational objects really  matters, in many cases.  But for us, here, let’s just move on.</p>
<p>Now let’s experiment with the code.  First, let’s use it to compute a polynomial, by calling it with <code class="docutils literal notranslate"><span class="pre">c</span></code> being a polynomial of degree 1.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">Mandelbrot</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">Poly</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span> <span class="c1"># The above code works with Polys (defined in previous cell)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.0 + 1.0·x¹ + 1.0·x² + 2.0·x³ + 5.0·x⁴ + 6.0·x⁵ + 6.0·x⁶ + 4.0·x⁷ +
1.0·x⁸
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">Mandelbrot</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.2</span><span class="p">)</span> <span class="c1"># The code also works with numeric input</span>
<span class="nb">print</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.10507775999999969
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">Mandelbrot</span><span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">j</span><span class="p">)</span> <span class="c1"># Will work with complex numbers also</span>
<span class="nb">print</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-1j
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">Mandelbrot</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.2</span><span class="p">)</span> <span class="c1"># Since it is iterative, we can ask for high iteration numbers on numerical input</span>
<span class="nb">print</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

<span class="c1"># Don&#39;t try that with c = Poly([0,1]) though; the result would be a vector of length half a billion or so</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.17381269635430296
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">zbig</span> <span class="o">=</span> <span class="n">Mandelbrot</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">Poly</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span> <span class="c1"># n=8 is ghastly already; n=9 is twice as ghastly</span>
<span class="nb">print</span><span class="p">(</span><span class="n">zbig</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.0 + 1.0·x¹ + 1.0·x² + 2.0·x³ + 5.0·x⁴ + 14.0·x⁵ + 42.0·x⁶ + 132.0·x⁷ +
365.0·x⁸ + 950.0·x⁹ + 2398.0·x¹⁰ + 5916.0·x¹¹ + 14290.0·x¹² +
33708.0·x¹³ + 77684.0·x¹⁴ + 175048.0·x¹⁵ + 385741.0·x¹⁶ + 831014.0·x¹⁷ +
1749654.0·x¹⁸ + 3598964.0·x¹⁹ + 7228014.0·x²⁰ + 14162220.0·x²¹ +
27049196.0·x²² + 50323496.0·x²³ + 91143114.0·x²⁴ + 160617860.0·x²⁵ +
275276716.0·x²⁶ + 458591432.0·x²⁷ + 742179284.0·x²⁸ + 1166067016.0·x²⁹ +
1777171560.0·x³⁰ + 2625062128.0·x³¹ + 3754272037.0·x³² +
5193067630.0·x³³ + 6939692682.0·x³⁴ + 8948546308.0·x³⁵ +
11120136162.0·x³⁶ + 13299362332.0·x³⁷ + 15286065700.0·x³⁸ +
16859410792.0·x³⁹ + 17813777994.0·x⁴⁰ + 17999433372.0·x⁴¹ +
17357937708.0·x⁴² + 15941684776.0·x⁴³ + 13910043524.0·x⁴⁴ +
11500901864.0·x⁴⁵ + 8984070856.0·x⁴⁶ + 6609143792.0·x⁴⁷ +
4562339774.0·x⁴⁸ + 2943492972.0·x⁴⁹ + 1766948340.0·x⁵⁰ + 981900168.0·x⁵¹ +
502196500.0·x⁵² + 234813592.0·x⁵³ + 99582920.0·x⁵⁴ + 37945904.0·x⁵⁵ +
12843980.0·x⁵⁶ + 3807704.0·x⁵⁷ + 971272.0·x⁵⁸ + 208336.0·x⁵⁹ +
36440.0·x⁶⁰ + 4976.0·x⁶¹ + 496.0·x⁶² + 32.0·x⁶³ + 1.0·x⁶⁴
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># If you forget the ordering, you can use keyword arguments (&quot;kwargs&quot;)</span>
<span class="n">zforgot</span> <span class="o">=</span> <span class="n">Mandelbrot</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="n">Poly</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">zforgot</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.0 + 1.0·x¹ + 1.0·x² + 2.0·x³ + 5.0·x⁴ + 14.0·x⁵ + 26.0·x⁶ + 44.0·x⁷ +
69.0·x⁸ + 94.0·x⁹ + 114.0·x¹⁰ + 116.0·x¹¹ + 94.0·x¹² + 60.0·x¹³ +
28.0·x¹⁴ + 8.0·x¹⁵ + 1.0·x¹⁶
</pre></div>
</div>
</div>
</div>
<p>One advantage of using Polynomials from NumPy is that they “know how to find their own roots”.  Let’s test that out; the Mandelbrot polynomials turn out to be tough customers, though (which is why they are used as test problems for <a class="reference external" href="https://en.wikipedia.org/wiki/MPSolve">MPSolve</a>, not at all coincidentally—we learned about them first from the MPSolve test suite).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">Mandelbrot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">Poly</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">rts</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">roots</span><span class="p">()</span>
<span class="c1"># print(rts)</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">rt</span><span class="o">.</span><span class="n">real</span> <span class="k">for</span> <span class="n">rt</span> <span class="ow">in</span> <span class="n">rts</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">rt</span><span class="o">.</span><span class="n">imag</span> <span class="k">for</span> <span class="n">rt</span> <span class="ow">in</span> <span class="n">rts</span><span class="p">]</span>
<span class="n">rootplot</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="o">-</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/mandelbrot_36_0.png" src="../_images/mandelbrot_36_0.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Great.  Are those roots correct?</span>
<span class="n">residuals</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">(</span><span class="n">rt</span><span class="p">)</span> <span class="k">for</span> <span class="n">rt</span> <span class="ow">in</span> <span class="n">rts</span><span class="p">]</span>
<span class="c1"># print(residuals) shows them all, and it&#39;s a confusing mess</span>
<span class="n">absresiduals</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">residuals</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">absresiduals</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>7.9566866626094e-11
</pre></div>
</div>
</div>
</div>
<p>That’s, that’s ok; it looks like we have in every case found the exact root of a polynomial different from <span class="math notranslate nohighlight">\(z_5(c)\)</span> by no more than <span class="math notranslate nohighlight">\(3\cdot 10^{-11}\)</span>.  Wait, what?  Well, putting in a computed root back to the polynomial (assuming it evaluates correctly) gives us a residual, say <span class="math notranslate nohighlight">\(r\)</span>.  That is <span class="math notranslate nohighlight">\(p(c^*) = r\)</span>, some (hopefully small) complex number.  But then <span class="math notranslate nohighlight">\(c^*\)</span> is the <em>exact</em> root of the following polynomial: <span class="math notranslate nohighlight">\(p(c) - r\)</span>.</p>
<p>Two questions: Did Python evaluate the polynomial well? That is, are the residuals accurate?  And second, what happens to a root if we slightly change a polynomial?  We’ve just wandered into numerical analysis territory.  Let’s first compare the built-in evaluation of a polynomial by its coefficients to our iterative code.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">r1</span> <span class="o">=</span> <span class="n">rts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">residual1byPython</span> <span class="o">=</span> <span class="n">p</span><span class="p">(</span><span class="n">r1</span><span class="p">)</span>
<span class="n">residual1byIteration</span> <span class="o">=</span> <span class="n">Mandelbrot</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">r1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using n = &quot;</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">For the computed root &quot;</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="s2">&quot;The residual by Python is &quot;</span><span class="p">,</span> <span class="n">residual1byPython</span><span class="p">,</span> 
      <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">while the residual by iteration is &quot;</span><span class="p">,</span> <span class="n">residual1byIteration</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Using n =  5 
For the computed root  (-1.985424253054647+0j) The residual by Python is  (7.9566866626094e-11+0j) 
while the residual by iteration is  (4.705902334478651e-11+0j)
</pre></div>
</div>
</div>
</div>
<p>We see some minor difference in that computation.  But it seems nothing to worry about.  Perhaps we should try a larger N, just to be sure?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">Mandelbrot</span><span class="p">(</span> <span class="n">N</span><span class="p">,</span> <span class="n">Poly</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">rts</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">roots</span><span class="p">()</span>
<span class="n">residuals</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">(</span><span class="n">rt</span><span class="p">)</span> <span class="k">for</span> <span class="n">rt</span> <span class="ow">in</span> <span class="n">rts</span><span class="p">]</span>
<span class="c1"># print(residuals) shows them all, and it&#39;s a confusing mess</span>
<span class="n">absresiduals</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">residuals</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">absresiduals</span><span class="p">))</span>
<span class="n">r1</span> <span class="o">=</span> <span class="n">rts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">residual1byPython</span> <span class="o">=</span> <span class="n">p</span><span class="p">(</span><span class="n">r1</span><span class="p">)</span>
<span class="n">residual1byIteration</span> <span class="o">=</span> <span class="n">Mandelbrot</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">r1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using n = &quot;</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="s2">&quot;and degree d = &quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">degree</span><span class="p">(),</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">For the computed root &quot;</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="s2">&quot;The residual by Python is &quot;</span><span class="p">,</span> <span class="n">residual1byPython</span><span class="p">,</span> 
      <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">while the residual by iteration is &quot;</span><span class="p">,</span> <span class="n">residual1byIteration</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">rt</span><span class="o">.</span><span class="n">real</span> <span class="k">for</span> <span class="n">rt</span> <span class="ow">in</span> <span class="n">rts</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">rt</span><span class="o">.</span><span class="n">imag</span> <span class="k">for</span> <span class="n">rt</span> <span class="ow">in</span> <span class="n">rts</span><span class="p">]</span>
<span class="n">rootplot</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="o">-</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.0006066958003114083
Using n =  6 and degree d =  32 
For the computed root  (-1.9963775684547609+0j) The residual by Python is  (0.0006066958003114083+0j) 
while the residual by iteration is  (0.0006180627093101965+0j)
</pre></div>
</div>
<img alt="../_images/mandelbrot_41_1.png" src="../_images/mandelbrot_41_1.png" />
</div>
</div>
<p>Ooh, that’s not very good.  When we try n=7 (below) we will see it get much worse; n=8 and worse yet (ridiculously worse). Try it yourself, and see!  The issue seems to either be Python’s polynomial rootfinder (we kind of thought it would be bad, but were hoping it was better than that), or its evaluation of the polynomial from its coefficients.  Of course the two things are connected.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">7</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">Mandelbrot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">Poly</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">rts</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">roots</span><span class="p">()</span>
<span class="n">residuals</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">(</span><span class="n">rt</span><span class="p">)</span> <span class="k">for</span> <span class="n">rt</span> <span class="ow">in</span> <span class="n">rts</span><span class="p">]</span>
<span class="c1"># print(residuals) shows them all, and it&#39;s a confusing mess</span>
<span class="n">absresiduals</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">residuals</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">absresiduals</span><span class="p">))</span>
<span class="n">r1</span> <span class="o">=</span> <span class="n">rts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">residual1byPython</span> <span class="o">=</span> <span class="n">p</span><span class="p">(</span><span class="n">r1</span><span class="p">)</span>
<span class="n">residual1byIteration</span> <span class="o">=</span> <span class="n">Mandelbrot</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">r1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using n = &quot;</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="s2">&quot;and degree d = &quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">degree</span><span class="p">(),</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">For the computed root &quot;</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="s2">&quot;The residual by Python is &quot;</span><span class="p">,</span> <span class="n">residual1byPython</span><span class="p">,</span> 
      <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">while the residual by iteration is &quot;</span><span class="p">,</span> <span class="n">residual1byIteration</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">rt</span><span class="o">.</span><span class="n">real</span> <span class="k">for</span> <span class="n">rt</span> <span class="ow">in</span> <span class="n">rts</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">rt</span><span class="o">.</span><span class="n">imag</span> <span class="k">for</span> <span class="n">rt</span> <span class="ow">in</span> <span class="n">rts</span><span class="p">]</span>
<span class="n">rootplot</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="o">-</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>813032006381.8693
Using n =  7 and degree d =  64 
For the computed root  (-2.2462535595968096-0.09498061432630142j) The residual by Python is  (483296675303.2549-653793061329.155j) 
while the residual by iteration is  (462256662183.5727-641275610267.817j)
</pre></div>
</div>
<img alt="../_images/mandelbrot_43_1.png" src="../_images/mandelbrot_43_1.png" />
</div>
</div>
<p>The fact that the roots near <span class="math notranslate nohighlight">\(-2\)</span> have <em>exploded</em> (which explains the fireworks GIF at the beginning of the online version of this unit) can be explained using what are known as <em>pseudozeros</em>.</p>
<p>Instead of pursuing that now, though, let us do something different. Namely, let us introduce an approximate formula for the <em>largest magnitude root</em>:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\rho_k \approx -2 + \frac32 \pi^2 4^{-k} + O(4^{-2k}) .
\end{equation*}\]</div>
<p>This formula was published in 2013 by one of us (RMC) and his then-student Piers W. Lawrence, and with the help of another of us (NJC).  We (the present authors, including EYSC) discuss it a bit in our paper <a class="reference external" href="https://doi.org/10.5206/mt.v1i1.14037">Some Facts and Conjectures on Mandelbrot Polynomials</a> but for now let’s just use it.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="n">rho</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="mi">4</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">k</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="nb">print</span><span class="p">(</span><span class="n">rho</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">-</span> <span class="o">-</span><span class="mf">1.9854242530543296</span><span class="p">)</span> <span class="c1"># Was -1.9854242530543296 above</span>
<span class="nb">print</span><span class="p">(</span><span class="n">rho</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="o">-</span> <span class="o">-</span><span class="mf">1.9963773629263977</span><span class="p">)</span> <span class="c1"># Was -1.9963773629263977+0j above</span>
<span class="nb">print</span><span class="p">(</span><span class="mi">4</span><span class="o">**</span><span class="mi">6</span><span class="o">*</span><span class="n">Mandelbrot</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">rho</span><span class="p">(</span><span class="mi">6</span><span class="p">)))</span> <span class="c1"># Like 4 times 4 (pattern observed experimentally)</span>
<span class="nb">print</span><span class="p">(</span><span class="mi">4</span><span class="o">**</span><span class="mi">7</span><span class="o">*</span><span class="n">Mandelbrot</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">rho</span><span class="p">(</span><span class="mi">7</span><span class="p">)))</span> <span class="c1"># Like 4 times 5</span>
<span class="nb">print</span><span class="p">(</span><span class="mi">4</span><span class="o">**</span><span class="mi">8</span><span class="o">*</span><span class="n">Mandelbrot</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">rho</span><span class="p">(</span><span class="mi">8</span><span class="p">)))</span> <span class="c1"># Like 4 times 6</span>
<span class="nb">print</span><span class="p">(</span><span class="mi">4</span><span class="o">**</span><span class="mi">9</span><span class="o">*</span><span class="n">Mandelbrot</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">rho</span><span class="p">(</span><span class="mi">9</span><span class="p">)))</span>  <span class="c1"># Like 4 times 7</span>
<span class="nb">print</span><span class="p">(</span><span class="mi">4</span><span class="o">**</span><span class="mi">13</span><span class="o">*</span><span class="n">Mandelbrot</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="n">rho</span><span class="p">(</span><span class="mi">13</span><span class="p">)))</span> <span class="c1"># Like 4 times 11</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-0.00011831862376210367
-8.279993125359653e-06
16.828183511695897
20.712561469499633
24.591600405416102
28.468529149366077
44.025735571980476
</pre></div>
</div>
</div>
</div>
<p>Now we see something interesting (to a numerical analyst).  The largest root (computed by Python) is actually better than its residual indicates!  We also see something interesting to an analyst, namely that there seems to be pattern in the residual. The experiments above predict that</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
z( \rho_k ) = \frac{4(k-2)}{4^k} + \cdots
\end{equation*}\]</div>
<p>and if this were true in general then this would be enough to deduce that there really is a root nearby: one Newton correction from here will help as we will see below (but this turns out to be tricky because the <em>second</em> derivatives are so <em>large</em> in this area; this fact interferes with the theory of Newton iteration, as you may eventually see in your numerical analysis class).</p>
<p>Now let us see a nifty way to compute derivatives of the iteration: just differentiate the statements in the loop, as follows!  But we have to be careful to do it in the right order (this is quite weird).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">MandelbrotWithDerivative</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="n">dz</span> <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">c</span>
    <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">c</span> <span class="c1"># try to inherit the type of c</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">z</span><span class="o">*</span><span class="n">dz</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># A bit iffy to add constants to Polynomials in Python, but maybe it works. Yes! It does!</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="n">c</span>
    <span class="k">return</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">dz</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">MandelbrotWithDerivative</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.2</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">MandelbrotWithDerivative</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">Poly</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(-1.1423999999999999, 0.32800000000000007)
(Polynomial([0., 1., 1., 2., 1.], domain=[-1.,  1.], window=[-1.,  1.]), Polynomial([1., 2., 6., 4.], domain=[-1.,  1.], window=[-1.,  1.]))
</pre></div>
</div>
</div>
</div>
<p>The output there is a bit hard to read, but it <em>looks</em> like it worked; the derivative of <span class="math notranslate nohighlight">\(z_3 = c + c^2 + 2c^3 + c^4\)</span> is indeed <span class="math notranslate nohighlight">\(1 + 2c + 6c^2 + 4c^3\)</span>.  We don’t really know what all that “domain” and “window” stuff is, but let’s just use the numerical part: if we plug in <span class="math notranslate nohighlight">\(c=-1.2\)</span> into <span class="math notranslate nohighlight">\(1 + 2c + 6c^2 + 4c^3\)</span> we should get <span class="math notranslate nohighlight">\(0.328\)</span>.  Let’s try it and see.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pd</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">pd</span><span class="p">(</span><span class="o">-</span><span class="mf">1.2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.3280000000000002
</pre></div>
</div>
</div>
</div>
<p>That looks good.  On this machine at the time of writing, the final digits are different (2 vs 7 from before) but it’s convincing.  That code computes both <span class="math notranslate nohighlight">\(z(c)\)</span> and <span class="math notranslate nohighlight">\(z'(c)\)</span>, with the same loop. So we can now take a Newton step. Or two.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pdp</span> <span class="o">=</span> <span class="n">MandelbrotWithDerivative</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">rho</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="n">improved</span> <span class="o">=</span> <span class="n">rho</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="o">-</span> <span class="n">pdp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">pdp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">rho</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="n">pdp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pdp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">improved</span><span class="p">,</span> <span class="n">Mandelbrot</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="n">improved</span><span class="p">))</span>
<span class="n">pdp2</span> <span class="o">=</span> <span class="n">MandelbrotWithDerivative</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">improved</span><span class="p">)</span>
<span class="n">better</span> <span class="o">=</span> <span class="n">improved</span> <span class="o">-</span> <span class="n">pdp2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">pdp2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">better</span><span class="p">,</span> <span class="n">Mandelbrot</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="n">better</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-1.996385642919523 0.004108443240160131 -432.51765820326005 -1.9963761440166177 2.7235905697420293e-06
-1.9963761377111966 1.2387868508767497e-12
</pre></div>
</div>
</div>
</div>
<p>Good!  Now we can (maybe) check Python’s rootfinder for larger <span class="math notranslate nohighlight">\(N\)</span>.  Let’s try <span class="math notranslate nohighlight">\(N=8\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">Mandelbrot</span><span class="p">(</span> <span class="n">N</span><span class="p">,</span> <span class="n">Poly</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">degree</span><span class="p">())</span>
<span class="n">rts</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">roots</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">rts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># Hopelessly wrong (can&#39;t be smaller than -2)</span>
<span class="n">rho8</span> <span class="o">=</span> <span class="n">rho</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">z</span><span class="p">(</span><span class="n">rho8</span><span class="p">))</span> <span class="c1"># Disaster has struck the polynomial evaluation</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Mandelbrot</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">rho8</span><span class="p">))</span> <span class="c1"># The iteration is better; *much* better</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>128
(-3.5776231050281337+0j)
1.2508702354809364e+33
0.0003752380432955338
</pre></div>
</div>
</div>
</div>
<p>We see that the built-in Python rootfinder has failed hopelessly, already at <span class="math notranslate nohighlight">\(N=8\)</span> (when there are only <span class="math notranslate nohighlight">\(128\)</span> roots to compute). There is a technical issue here: this polynomial is what is known as <em>ill-conditioned</em>. That means that it is <em>sensitive to changes in its input</em>.  We could pursue that, with the notion of <em>pseudozeros</em> (and that’s what leads to the fireworks GIF that we opened this section with online), but for the moment we will try another tack: instead of working with Mandelbrot polynomials, we will work with Mandelbrot <em>matrices</em>, which turn out to be much better behaved.</p>
<div class="tip admonition" id="mandelbrotactivity-7">
<p class="admonition-title">Mandelbrot Activity 7</p>
<p>Prove by induction that the code <code class="docutils literal notranslate"><span class="pre">MandelbrotWithDerivative</span></code> computes the correct derivative of every Mandelbrot polynomial. Rather, that it <em>would</em> compute the correct derivative if the underlying arithmetic were exact. You might need what is known as a <em>loop invariant</em>: something that is true before the loop starts, and is true at the start of every iteration, and at the end of every iteration (though not necessarily true after each intermediate step of the iteration). But this loop is simple enough that a direct induction also works.
<a class="reference internal" href="../Solutions/Reports%20on%20Mandelbrot%20Activities.html#mandelbrotactivityreport-7"><span class="std std-ref">[Our proof]</span></a></p>
</div>
<div class="tip admonition" id="mandelbrotactivity-8">
<p class="admonition-title">Mandelbrot Activity 8</p>
<p>Are the zeros of the derivatives of the Mandelbrot polynomials in the Mandelbrot set?
<a class="reference internal" href="../Solutions/Reports%20on%20Mandelbrot%20Activities.html#mandelbrotactivityreport-8"><span class="std std-ref">[We think so, but we don’t know.]</span></a></p>
</div>
</section>
<section id="eigenvalues-and-roots-of-polynomials">
<h2>Eigenvalues and roots of polynomials<a class="headerlink" href="#eigenvalues-and-roots-of-polynomials" title="Permalink to this headline">#</a></h2>
<p>In the previous unit, on Bohemian matrices, we introduced matrices (via determinants) and eigenvalues of matrices.  In this unit, we’re going to use them without defining them further.  This is kind of backwards if you haven’t had a course in linear algebra, but we also saw two-by-two matrices at least back in the Fibonacci unit, and many high schools do cover matrices at least a little bit.  Eigenvalues, not so much.  But then, eigenvalues aren’t covered enough in many first courses in linear algebra, either, so the practice here is justified, in our minds.</p>
<p>Eigenvalues of matrices are related to roots of polynomials in the following two ways: first, if we are given a monic polynomial, say <span class="math notranslate nohighlight">\(x^3 -2 x^2 - 5x + 9\)</span>, then the three-by-three matrix below (three by three because the polynomial has degree <span class="math notranslate nohighlight">\(3\)</span>)</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{A} = \begin{bmatrix}
0 &amp; 0 &amp; -9 \\
1 &amp; 0 &amp;  5 \\
0 &amp; 1 &amp;  2
\end{bmatrix}
\end{split}\]</div>
<p>has as its <em>eigenvalues</em> the exact roots of the polynomial.  Notice that the <em>negatives</em> of the polynomial coefficients appear in the final column, and that there is a diagonal of 1s appearing <em>below</em> the main diagonal of the matrix.  This construction is perfectly general: take any monic polynomial, negate its coefficients (except the leading coefficient, which is 1), list them in increasing degree as you go down the final column, and throw 1s along the subdiagonal, then you have a matrix whose eigenvalues are the roots of the original polynomial.  This is called a <em>companion matrix</em> for the polynomial (there are many: this is the <a class="reference external" href="https://en.wikipedia.org/wiki/Ferdinand_Georg_Frobenius">Frobenius</a> companion matrix).</p>
<p>Since Python (and every scientific computing language) has a routine to compute eigenvalues, this gives us a perfectly straightforward way to find the roots of a polynomial.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">eigvals</span><span class="p">,</span> <span class="n">tri</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">9</span>
<span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">e</span> <span class="o">=</span> <span class="n">eigvals</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[ 0.  0. -9.]
 [ 1.  0.  5.]
 [ 0.  1.  2.]] [-2.18194334+0.j  1.59357935+0.j  2.58836399+0.j]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">roots</span><span class="p">())</span>
<span class="n">residuals</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">e</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>9.0 - 5.0·x¹ - 2.0·x² + 1.0·x³ [-2.18194334  1.59357935  2.58836399]
[(-4.263256414560601e-14+0j), (-1.7763568394002505e-15+0j), (-3.552713678800501e-15+0j)]
</pre></div>
</div>
</div>
</div>
<p>Voilà.  The same numbers appear (possibly in a different order).  This is in fact how numpy’s <code class="docutils literal notranslate"><span class="pre">roots</span></code> command works, and how the <code class="docutils literal notranslate"><span class="pre">Polynomial</span></code> package allows its polynomials to find their roots.  Notice that the values of the polynomial at the computed eigenvalues are all <em>nearly</em> zero, and the difference (when its not actually zero) is small enough to be considered the effects of rounding error.</p>
<section id="but-wait-that-s-backwards">
<h3>But wait, that’s backwards!<a class="headerlink" href="#but-wait-that-s-backwards" title="Permalink to this headline">#</a></h3>
<p>The second way of connecting matrices and polynomials, though, is one we have seen already: given a matrix, we define its eigenvalues as the <em>roots of its “characteristic polynomial”</em>.  This is “reducing the problem to a previously solved one”, if you know how to find roots of polynomials.  Turns out, that’s actually harder, computationally speaking!  But for the record, here is where we got that polynomial in the first place.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{B} = \begin{bmatrix}
2 &amp; -1 &amp; 2 
\\
 -1 &amp; 0 &amp; 1 
\\
 1 &amp; 2 &amp; 0 
\end{bmatrix}
\end{split}\]</div>
<p>which has characteristic polynomial det<span class="math notranslate nohighlight">\((\lambda\mathbf{I}-\mathbf{B}) = \lambda^{3}-2 \lambda^{2}-5 \lambda +9 \)</span>.  Apart from the variable name, this is the same polynomial as above.  Therefore both <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> have the same <em>eigenvalues</em>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>

<span class="nb">print</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">eigvals</span><span class="p">(</span><span class="n">B</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[ 2 -1  2]
 [-1  0  1]
 [ 1  2  0]] [-2.18194334+0.j  2.58836399+0.j  1.59357935+0.j]
</pre></div>
</div>
</div>
</div>
<div class="proof remark admonition" id="eigenvalue_remark">
<p class="admonition-title"><span class="caption-number">Remark 1 </span></p>
<section class="remark-content" id="proof-content">
<p>It may seem silly, and wasteful, to solve polynomials by finding eigenvalues of matrices.  Against that, we actually have software for eigenvalue problems that is <em>really good</em> in the sense that it is robust, accurate, and efficient.  So we are “reducing the problem to a previously solved problem” which is like recycling, and so is not wasteful in that sense.  However, at some point the wastefulness (we store <span class="math notranslate nohighlight">\(d^2\)</span> numbers, or sometimes even more, to attack a polynomial of degree <span class="math notranslate nohighlight">\(d\)</span>) will catch up to us.  But it turns out that this “wasteful” approach gets us <em>farther</em> than trying to solve the Mandelbrot polynomials directly does.</p>
<p>It does turn out to be wasteful to start with a matrix, compute a characteristic polynomial, and then construct another matrix.  You might just as well have computed the eigenvalues of the original matrix.  Indeed, that’s almost always <em>much</em> better from the point of view of numerical stability.  But that is a topic for your numerical analysis class.</p>
</section>
</div><div class="tip admonition" id="mandelbrotactivity-9">
<p class="admonition-title">Mandelbrot Activity 9</p>
<p>This is a more theoretical activity, and helps to explain why polynomials are sometimes hard to deal with directly in numerical computation.  This particular discussion is not in many textbooks, but is in some.
“A good numerical method gives you the exact solution to a nearby problem”.  This is an informal definition of <em>numerical stability</em>.  An <em>algorithm</em> is “numerically stable” if it gives you the exact solution, not to the problem you were trying to solve (say the polynomial <span class="math notranslate nohighlight">\(z(c) = 0\)</span>) but instead to a <em>nearby</em> problem, say <span class="math notranslate nohighlight">\(z(c) - 10^{-16}i = 0\)</span>.  Some problems, however, are <em>sensitive to changes</em> (in the vernacular of numerical analysis, <em>ill-conditioned</em>).  Consider the polynomial
<span class="math notranslate nohighlight">\(z(c) = \sum_{k=0}^d a_k c^k\)</span>
and a <em>perturbed</em> (changed) polynomial
<span class="math notranslate nohighlight">\(z(c) + \Delta(c) = \sum_{k=0}^d a_k(1+s_k) c^k\)</span>
where the coefficients <span class="math notranslate nohighlight">\(a_k\)</span> have all been changed by small relative amounts <span class="math notranslate nohighlight">\(s_k\)</span>.  Suppose further that all <span class="math notranslate nohighlight">\(|s_k| \le t\)</span>, some tiny number. By using the triangle inequality, show that
<span class="math notranslate nohighlight">\(
| \Delta(c) | \le K(c) t
\)</span>
where
<span class="math notranslate nohighlight">\(
K(c) = \sum_{k=0}^d |a_k| |c|^k
\)</span>
This number <span class="math notranslate nohighlight">\(K(c)\)</span> serves as a kind of <em>condition number</em> for the polynomial: the larger it is, the more sensitive the polynomial is.  Plot the condition numbers (on a log scale!) of the Mandelbrot polynomials <span class="math notranslate nohighlight">\(z_6(c)\)</span> and <span class="math notranslate nohighlight">\(z_7(c)\)</span> on <span class="math notranslate nohighlight">\(-2 \le c \le 0\)</span>.
<a class="reference internal" href="../Solutions/Reports%20on%20Mandelbrot%20Activities.html#mandelbrotactivityreport-9"><span class="std std-ref">[Our thoughts]</span></a></p>
</div>
<div class="tip admonition" id="mandelbrotactivity-10">
<p class="admonition-title">Mandelbrot Activity 10</p>
<p><strong>Pseudozeros</strong>.  The zeros of <span class="math notranslate nohighlight">\(z(c) - 10^{-k}\exp(i\theta)\)</span> for <span class="math notranslate nohighlight">\(k=6\)</span>, say, represent a <em>curve</em> in <span class="math notranslate nohighlight">\(c\)</span> space (let <span class="math notranslate nohighlight">\(\theta\)</span> vary from <span class="math notranslate nohighlight">\(-\pi\)</span> to <span class="math notranslate nohighlight">\(\pi\)</span> so the tiny perturbation <span class="math notranslate nohighlight">\(10^{-6}\exp(i\theta)\)</span> turns a full circle in the complex plane). As <span class="math notranslate nohighlight">\(k\)</span> is taken larger, one expects these curves to surround the zeros of <span class="math notranslate nohighlight">\(z(c)\)</span> itself.  Graph some pseudozeros of a Mandelbrot polynomial.<br />
<a class="reference internal" href="../Solutions/Reports%20on%20Mandelbrot%20Activities.html#mandelbrotactivityreport-10"><span class="std std-ref">[Our code]</span></a></p>
</div>
</section>
</section>
<section id="mandelbrot-matrices">
<h2>Mandelbrot matrices<a class="headerlink" href="#mandelbrot-matrices" title="Permalink to this headline">#</a></h2>
<p>Let <span class="math notranslate nohighlight">\(\mathbf{M}_1 = [c]\)</span> be the <span class="math notranslate nohighlight">\(1\)</span>-by-<span class="math notranslate nohighlight">\(1\)</span> matrix whose determinant is <span class="math notranslate nohighlight">\(z_1(c)\)</span>. Now define</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    \mathbf{M}_{k+1} = 
    \begin{bmatrix}
    \mathbf{M}_k &amp; -c \mathbf{e}_1\mathbf{e}_{d_k}^T \\
    \mathbf{e}_1\mathbf{e}_{d_k}^T &amp; \mathbf{M}_k
    \end{bmatrix} .
\end{equation*}\]</div>
<p>Here the <span class="math notranslate nohighlight">\(\mathbf{e}_j\)</span>’s are the unit elementary vectors of dimension <span class="math notranslate nohighlight">\(d_k=2^{k-1}\)</span>; all they do together here is put a <span class="math notranslate nohighlight">\(1\)</span> in the top right corner of the relevant blocks.</p>
<p>Just to explain that a bit more: if the dimension is 5, say, then <span class="math notranslate nohighlight">\(\mathbf{e}_1^T = [1,0,0,0,0]\)</span> and <span class="math notranslate nohighlight">\(\mathbf{e}_5^T = [0,0,0,0,1]\)</span>.  The superscript T means “transpose” and we can use it (as in this paragraph) just to save space and write the column vectors on one line, or we can use it as in the formula to indicate what we really mean.  Elementary vectors are all zero except for one 1, and they are used here just to keep the notation neat.  They do have many other uses, so we don’t mind introducing a notation for such a simple-looking thing.  The product <span class="math notranslate nohighlight">\(\mathbf{e}_1^T\mathbf{e}_5\)</span> is a <span class="math notranslate nohighlight">\(5\)</span> by <span class="math notranslate nohighlight">\(5\)</span> matrix that is all zero except for a <span class="math notranslate nohighlight">\(1\)</span> in the upper right hand corner.</p>
<p>The next two Mandelbrot matrices are then, by this recurrence relation,</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    \left[\begin{array}{cc}
c  &amp; -c  
\\
 1 &amp; c  
\end{array}\right]
\end{equation*}\]</div>
<p>and</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
    \left[\begin{array}{cccc}
c  &amp; -c  &amp; 0 &amp; \mathbf{-{c}}  
\\
 1 &amp; c  &amp; 0 &amp; 0 
\\
 0 &amp; \mathbf{1} &amp; c  &amp; -c  
\\
 0 &amp; 0 &amp; 1 &amp; c  
\end{array}\right]
\end{equation*}\]</div>
<p>where we have bold-faced the two new entries that connect the two copies of <span class="math notranslate nohighlight">\(\mathbf{M}_2\)</span> that lie in the upper left corner and bottom right corner.</p>
<p>We can write this matrix as <span class="math notranslate nohighlight">\(\mathbf{A} + c\mathbf{B}\)</span> where</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\mathbf{A} = \begin{bmatrix}
0 &amp; 0 &amp; 0 &amp; 0 \\
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 
\end{bmatrix}
\end{equation*}\]</div>
<p>and</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\mathbf{B} = \begin{bmatrix}
1 &amp; -1 &amp; \phantom{-}0 &amp; -1 \\
0 &amp; \phantom{-}1 &amp; \phantom{-}0 &amp; \phantom{-}0 \\
0 &amp; \phantom{-}0 &amp; \phantom{-}1 &amp; -1\\
0 &amp; \phantom{-}0 &amp; \phantom{-}0 &amp; \phantom{-}1 
\end{bmatrix} .
\end{equation*}\]</div>
<p>Finding values of <span class="math notranslate nohighlight">\(c\)</span> which make the determinant of <span class="math notranslate nohighlight">\(\mathbf{A} + c \mathbf{B}\)</span> equal to zero is an example of what is called a <em>generalized</em> eigenvalue problem, and <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.eigvals.html#scipy.linalg.eigvals">SciPy’s linalg routine eigvals</a> is set up do do this already, except that it solves problems of the form <span class="math notranslate nohighlight">\(\det( \mathbf{A} - \lambda \mathbf{B} ) = 0\)</span> so we will have to change the sign of our matrix <span class="math notranslate nohighlight">\(\mathbf{B}\)</span>.</p>
<p>The matrix <span class="math notranslate nohighlight">\(\mathbf{A_k}\)</span> is analogous at every dimension <span class="math notranslate nohighlight">\(k\)</span>: it is zero except for the subdiagonal which is all <span class="math notranslate nohighlight">\(1\)</span>s.  The matrix <span class="math notranslate nohighlight">\(\mathbf{B}_k\)</span> is very simply constructed from two copies of the matrix <span class="math notranslate nohighlight">\(\mathbf{B}_{k-1}\)</span> (if <span class="math notranslate nohighlight">\(k&gt;1\)</span>), with an additional <span class="math notranslate nohighlight">\(-1\)</span> tucked into the upper right corner.  We might as well build <span class="math notranslate nohighlight">\(-\mathbf{B}_k\)</span> instead of building <span class="math notranslate nohighlight">\(\mathbf{B}_k\)</span> while we are at it.  We will do this <em>recursively</em>.  See the code below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">getMinusBmatrix</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">d</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> 
        <span class="n">minusB</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># Return a 1 by 1 matrix of ones</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">minusB</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">zeroBlock</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">d</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="n">d</span><span class="o">//</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># The double slash enforces integer division</span>
        <span class="n">smallerB</span>  <span class="o">=</span> <span class="n">getMinusBmatrix</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># This is a recursive program: it calls itself.</span>
        <span class="n">minusB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bmat</span><span class="p">(</span><span class="s1">&#39;smallerB, zeroBlock; zeroBlock, smallerB&#39;</span><span class="p">)</span>
        <span class="n">minusB</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># Glue the two blocks together with a 1 in the upper right corner</span>
        <span class="k">return</span><span class="p">(</span><span class="n">minusB</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">getAmatrix</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">d</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">d</span><span class="p">,</span><span class="n">d</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">d</span><span class="p">):</span>
        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>    <span class="c1"># Subdiagonal entries are all 1, everything else is 0</span>
    <span class="k">return</span> <span class="n">A</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">getAmatrix</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">getMinusBmatrix</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">A</span> <span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2 [[0. 0.]
 [1. 0.]] 
 [[-1.  1.]
 [ 0. -1.]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">getAmatrix</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">getMinusBmatrix</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3 [[0. 0. 0. 0.]
 [1. 0. 0. 0.]
 [0. 1. 0. 0.]
 [0. 0. 1. 0.]] 
 [[-1.  1.  0.  1.]
 [ 0. -1.  0.  0.]
 [ 0.  0. -1.  1.]
 [ 0.  0.  0. -1.]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">getAmatrix</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">getMinusBmatrix</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4 [[0. 0. 0. 0. 0. 0. 0. 0.]
 [1. 0. 0. 0. 0. 0. 0. 0.]
 [0. 1. 0. 0. 0. 0. 0. 0.]
 [0. 0. 1. 0. 0. 0. 0. 0.]
 [0. 0. 0. 1. 0. 0. 0. 0.]
 [0. 0. 0. 0. 1. 0. 0. 0.]
 [0. 0. 0. 0. 0. 1. 0. 0.]
 [0. 0. 0. 0. 0. 0. 1. 0.]] 
 [[-1.  1.  0.  1.  0.  0.  0.  1.]
 [ 0. -1.  0.  0.  0.  0.  0.  0.]
 [ 0.  0. -1.  1.  0.  0.  0.  0.]
 [ 0.  0.  0. -1.  0.  0.  0.  0.]
 [ 0.  0.  0.  0. -1.  1.  0.  1.]
 [ 0.  0.  0.  0.  0. -1.  0.  0.]
 [ 0.  0.  0.  0.  0.  0. -1.  1.]
 [ 0.  0.  0.  0.  0.  0.  0. -1.]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">getAmatrix</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">getMinusBmatrix</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="c1"># Now compute the generalized eigenvalues</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">eigvals</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">real</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">E</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">imag</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">E</span><span class="p">]</span>
<span class="n">residuals</span> <span class="o">=</span> <span class="p">[</span><span class="n">Mandelbrot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">E</span><span class="p">]</span>
<span class="n">absresiduals</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">residuals</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">absresiduals</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4.134470543704083e-11
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">rootplot</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="o">-</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/mandelbrot_76_0.png" src="../_images/mandelbrot_76_0.png" />
</div>
</div>
<p>This shows that (at least for <span class="math notranslate nohighlight">\(N=8\)</span>) solving the (generalized) eigenvalue problem is <em>much</em> more accurate than trying to solve the explicit Mandelbrot polynomial at the same dimension.</p>
<p>Now it turns out that the matrix method will also (eventually) run into trouble, at about <span class="math notranslate nohighlight">\(N=17\)</span> (when RMC’s computer tries to store all the zeros in the <span class="math notranslate nohighlight">\(d\)</span> by <span class="math notranslate nohighlight">\(d\)</span> matrix, and runs out of memory); the dimension of the matrix for <span class="math notranslate nohighlight">\(N=14\)</span> is already <span class="math notranslate nohighlight">\(16384\)</span> by <span class="math notranslate nohighlight">\(16384\)</span>, using about sixteen thousand times too much memory, and so this isn’t that surprising.</p>
<p>Here are some results of running this code on a 2019 Microsoft Surface Pro (1.3GHz, 4 cores; not that the 4 cores are specially used by Python).  We report the Mandelbrot index, the dimension, the time taken in seconds, and the maximum absolute value of the residual.  We see that in all the cases we get accurate roots, but we also see that as the dimension doubles the cost increases by <em>more</em> than a factor of <span class="math notranslate nohighlight">\(2^3=8\)</span>, consistently; we do not know why.  We estimated that running this for <span class="math notranslate nohighlight">\(N=14\)</span> would take about <span class="math notranslate nohighlight">\(3\)</span> hours (it took <span class="math notranslate nohighlight">\(2\)</span> hours and <span class="math notranslate nohighlight">\(22\)</span> minutes), and would return all roots to about single precision accuracy, which it did (we are working in double precision, of course).  We could use a supposedly faster language (Julia, for instance: except that, ironically, Python seems to be faster for generalized eigenvalues) to speed the computation up, but the <em>condition number</em> of these eigenvalues also seems to be growing; this means the accuracy will diminish.  Another approach seems needed: see MPSolve, and see <a class="reference external" href="https://ir.lib.uwo.ca/etd/4028/">Eunice Chan’s Master’s thesis</a>.  Also, <em>generalized</em> eigenvalue code is (quite a bit!) slower than code for the simple eigenvalue problem <span class="math notranslate nohighlight">\(\mathbf{A}\mathbf{x} = \lambda \mathbf{x}\)</span> and we could convert our generalized eigenvalue problem to a simple one by postmultiplying by <span class="math notranslate nohighlight">\(\mathbf{B}^{-1}\)</span> (we can even do that analytically, and this works <em>very</em> well: see the activities) but for now we will step away from the keyboard, happy with accurately computing the roots of the degree <span class="math notranslate nohighlight">\(8192\)</span> Mandelbrot polynomial by means of a generalized eigenvalue problem.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>n</p></th>
<th class="head"><p>d</p></th>
<th class="head"><p>time(s)</p></th>
<th class="head"><p>slowdown</p></th>
<th class="head"><p>max residual</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>9</p></td>
<td><p>256</p></td>
<td><p>0.06</p></td>
<td><p></p></td>
<td><p><span class="math notranslate nohighlight">\(2.8\cdot 10^{-11}\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>10</p></td>
<td><p>512</p></td>
<td><p>0.6</p></td>
<td><p>10.</p></td>
<td><p><span class="math notranslate nohighlight">\(1.8\cdot 10^{-10}\)</span></p></td>
</tr>
<tr class="row-even"><td><p>11</p></td>
<td><p>1024</p></td>
<td><p>6</p></td>
<td><p>10.</p></td>
<td><p><span class="math notranslate nohighlight">\(1.6\cdot 10^{-9}\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>12</p></td>
<td><p>2048</p></td>
<td><p>78</p></td>
<td><p>13.</p></td>
<td><p><span class="math notranslate nohighlight">\(3.5\cdot 10^{-9}\)</span></p></td>
</tr>
<tr class="row-even"><td><p>13</p></td>
<td><p>4096</p></td>
<td><p>850</p></td>
<td><p>11.</p></td>
<td><p><span class="math notranslate nohighlight">\(2.0\cdot 10^{-8}\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>14</p></td>
<td><p>8192</p></td>
<td><p>8512</p></td>
<td><p>10.</p></td>
<td><p><span class="math notranslate nohighlight">\(4.0\cdot 10^{-7}\)</span></p></td>
</tr>
</tbody>
</table>
<div class="proof remark admonition" id="memory_remark">
<p class="admonition-title"><span class="caption-number">Remark 2 </span></p>
<section class="remark-content" id="proof-content">
<p>If we are more careful with memory and use what are known as <em>sparse</em> matrices, then we can go a lot farther.  Using sparse matrices, and special algorithms for finding eigenvalues of sparse matrices, Piers Lawrence was able to take this approach up to about a half a million eigenvalues (<span class="math notranslate nohighlight">\(n=19\)</span>); it was a bit awkward to make sure that we got all the eigenvalues once and only once, but it worked.  Eunice Chan got up over two million eigenvalues with a different method (homotopy continuation), but the champion is still MPSolve; Dario Bini and Leonard Robol used their software to compute over four million roots of Mandelbrot polynomials.</p>
</section>
</div><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">N</span><span class="o">=</span><span class="mi">9</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">getAmatrix</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">getMinusBmatrix</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="c1"># print( A, &quot;\n&quot;, B )</span>
<span class="n">built</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">eigvals</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">real</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">E</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">imag</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">E</span><span class="p">]</span>
<span class="n">residuals</span> <span class="o">=</span> <span class="p">[</span><span class="n">Mandelbrot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">E</span><span class="p">]</span>
<span class="n">absresiduals</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">residuals</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">absresiduals</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time taken was &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">-</span><span class="n">built</span><span class="p">,</span> <span class="s2">&quot;seconds to find d=&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> 
      <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">generalized eigenvalues of matrices that took &quot;</span><span class="p">,</span> <span class="n">built</span><span class="o">-</span><span class="n">start</span><span class="p">,</span> <span class="s2">&quot;seconds to build&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.0914269488182526e-10
Time taken was  0.13111090660095215 seconds to find d= 256 
generalized eigenvalues of matrices that took  0.0018339157104492188 seconds to build
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">rootplot</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="o">-</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/mandelbrot_80_0.png" src="../_images/mandelbrot_80_0.png" />
</div>
</div>
<p>The following is the resulting image from the case <span class="math notranslate nohighlight">\(N=14\)</span>:</p>
<a class="reference internal image-reference" href="../_images/MandelbrotZ14.png"><img alt="Our best eigenvalue image of the roots of a Mandelbrot polynomial of degree 8192" class="align-center" src="../_images/MandelbrotZ14.png" style="height: 400px;" /></a>
</section>
<section id="looking-back-at-the-programming-constructs-used-in-this-unit">
<h2>Looking back at the programming constructs used in this unit<a class="headerlink" href="#looking-back-at-the-programming-constructs-used-in-this-unit" title="Permalink to this headline">#</a></h2>
<p>We introduced more linear algebra routines.  We found out how to compute roots of polynomials (by computing eigenvalues of companion matrices, using the eigenvalue routine as a “black box”). We used the <code class="docutils literal notranslate"><span class="pre">//</span></code> integer division operation for the first time.</p>
<p>We introduced “hints” for the types of arguments in a procedure.  This is more important in other languages than in Python (indeed, it is <em>critical</em> for many).</p>
<p>We showed a programmatic method for inheriting types (not actually necessary in the example we used, because adding scalars to <code class="docutils literal notranslate"><span class="pre">Polynomials</span></code> produces a <code class="docutils literal notranslate"><span class="pre">Polynomial</span></code> anyway).  And in the only case where it <em>would</em> matter, it didn’t work because Python was lazy about 0 times a Polynomial (it should return a Polynomial with zero coefficients, but just returns a scalar 0).</p>
<p>We showed that one can <em>differentiate a program</em> or <em>take the derivative of a program</em> (indeed this can be done by computers as well, in which case it is called “automatic differentiation” or “program differentiation”).  Doing this <em>efficiently</em> is sometimes an issue, but given how tedious differentiation can be, we will take all the help we can get.</p>
</section>
<section id="more-mandelbrot-activities">
<h2>More Mandelbrot Activities<a class="headerlink" href="#more-mandelbrot-activities" title="Permalink to this headline">#</a></h2>
<p id="mandelbrotactivity-11">11. Write <span class="math notranslate nohighlight">\(\mathbf{C} = \mathbf{A}\mathbf{B}^{-1}\)</span> and show that the generalized eigenvalues of <span class="math notranslate nohighlight">\(\mathbf{A}-\lambda\mathbf{B}\)</span> are the simple eigenvalues of <span class="math notranslate nohighlight">\(\mathbf{C} - \lambda\mathbf{I}\)</span>.  Find <span class="math notranslate nohighlight">\(\mathbf{C}\)</span> for the Mandelbrot matrices above, and code it up and compare the times to compute simple eigenvalues versus generalized eigenvalues. How high a degree can you get to?  We stopped at <span class="math notranslate nohighlight">\(N=16\)</span>, where the computation took about an hour and a half, and the residual was about <span class="math notranslate nohighlight">\(4.0e-5\)</span>.  The current record is held by <a class="reference external" href="https://numpi.dm.unipi.it/software/mpsolve">MPSolve</a> with <span class="math notranslate nohighlight">\(k=23\)</span>, so over <span class="math notranslate nohighlight">\(4\)</span> million roots (using multiple precision); we don’t think eigenvalue methods can get that high, but we think <a class="reference external" href="https://ir.lib.uwo.ca/etd/4028/">homotopy methods</a> can (also called “continuation methods” as they were in the Rootfinding unit, as a “really good way to get initial estimates”), although they haven’t yet. <a class="reference internal" href="../Solutions/Reports%20on%20Mandelbrot%20Activities.html#mandelbrotactivityreport-11"><span class="std std-ref">[Our thoughts]</span></a></p>
<p id="mandelbrotactivity-12">12. Eigenvalues of perturbed matrices are called <em>pseudospectra</em> (the set of eigenvalues themselves is called the <em>spectrum</em>).  <span class="math notranslate nohighlight">\(\Lambda_\varepsilon(\mathbf{A}) := \{z : \exists \mathbf{E} \backepsilon \mathrm{det}(z\mathbf{I} - (\mathbf{A}+\mathbf{E})) = 0 \&amp; \|\mathbf{E}\| \le \varepsilon\}\)</span>. That definition means, in words, that the pseudospectrum at size <span class="math notranslate nohighlight">\(\varepsilon\)</span> is the set of complex numbers <span class="math notranslate nohighlight">\(z\)</span> that are the exact eigenvalues of matrices perturbed by another matrix <span class="math notranslate nohighlight">\(\mathbf{E}\)</span> which is at most <span class="math notranslate nohighlight">\(\varepsilon\)</span> in norm.  Check out the <a class="reference external" href="https://www.cs.ox.ac.uk/pseudospectra/">Pseudospectra gateway</a> and then do some pseudospectral experiments with Mandelbrot matrices. <a class="reference internal" href="../Solutions/Reports%20on%20Mandelbrot%20Activities.html#mandelbrotactivityreport-12"><span class="std std-ref">[Our thoughts]</span></a></p>
<p id="mandelbrotactivity-13">13. Other families of polynomials like the Mandelbrot polynomials can be defined: Fibonacci–Mandelbrot polynomials defined by <span class="math notranslate nohighlight">\(q_{n+1}(z) = z q_n(z) q_{n-1}(z) + 1\)</span> and <span class="math notranslate nohighlight">\(q_0(z)=0\)</span> and <span class="math notranslate nohighlight">\(q_1(z) = 1\)</span>, for instance; or Fibonacci–Narayana polynomials.  Define your own polynomials by recurrence relation, and find your own matrices whose eigenvalues are their roots, and draw their eigenvalues.  We have only done a few of these, and there are infinitely many to choose from.  It’s possible your results will be completely new (and therefore publishable). <a class="reference internal" href="../Solutions/Reports%20on%20Mandelbrot%20Activities.html#mandelbrotactivityreport-13"><span class="std std-ref">[Our thoughts]</span></a></p>
<p id="mandelbrotactivity-14">14. The paper <a class="reference external" href="https://doi.org/10.5206/mt.v1i1.14037">Some Facts and Conjectures on Mandelbrot Polynomials</a> contains a formula for the <em>Mandelbrot Generating Function</em> MGF(k,c), which <em>analytically solves</em> the Mandelbrot iteration <span class="math notranslate nohighlight">\(z_{n+1} = z_n^2 + c\)</span>, at least for <span class="math notranslate nohighlight">\(c\)</span> <em>outside</em> the Mandelbrot set.  This means that we could (say) take half an iteration—and find <span class="math notranslate nohighlight">\(z_{1/2}(c)\)</span> or <span class="math notranslate nohighlight">\(z_{3/2}(c)\)</span>.  As with <a class="reference external" href="https://youtu.be/ghxQA3vvhsk">Stand-Up Math’s Video on Complex Fibonacci Numbers</a> these are likely to be <em>complex numbers</em>.  So far as we know, no-one (not even us) has computed these.  Do so, for (say) <span class="math notranslate nohighlight">\(c=1\)</span> or <span class="math notranslate nohighlight">\(c=2\)</span>.  Plot the results.  This, also, might be publishable (again, <a class="reference external" href="https://www.mapletransactions.org">Maple Transactions</a> might be a good place). <a class="reference internal" href="../Solutions/Reports%20on%20Mandelbrot%20Activities.html#mandelbrotactivityreport-14"><span class="std std-ref">[Our thoughts]</span></a></p>
<p id="mandelbrotactivity-15">15. A <a class="reference external" href="https://en.wikipedia.org/wiki/Companion_matrix">companion matrix</a> for a polynomial (say <span class="math notranslate nohighlight">\(P(\lambda)\)</span>) is simply a matrix <span class="math notranslate nohighlight">\(C\)</span> whose eigenvalues are the roots of <span class="math notranslate nohighlight">\(P(\lambda)\)</span>.  Every matrix has a characteristic polynomial whose roots are its eigenvalues; what’s interesting is that this can be run the other way (it’s a bit more complicated because “Frobenius companion matrices” as in the link above have special properties).  But companion matrices are not unique: any matrix similar to a companion matrix <span class="math notranslate nohighlight">\(\mathbf{S}\mathbf{C}\mathbf{S}^{-1}\)</span> is also a companion matrix for that same <span class="math notranslate nohighlight">\(P(\lambda)\)</span>.  Suppose that you have a polynomial with <em>integer</em> coefficients.  Then the Frobenius companion matrix has (those same) integers as entries, together with ones and zeros.  Therefore, out of all integer companion matrices for <span class="math notranslate nohighlight">\(P(\lambda)\)</span>, there must be one with <em>minimal height</em>: the height of the matrix is the size of the largest absolute value of any entry in the matrix.  Mandelbrot matrices as defined above have height <span class="math notranslate nohighlight">\(1\)</span>, which is the smallest possible for integer companions, and are therefore “minimal height”.  Note that the size of the coefficients of the polynomial are exponential in the degree! So the height of the Frobenius companion matrix of Mandelbrot polynomials is likewise exponential.  Not much is known about <a class="reference external" href="https://link.springer.com/article/10.1007/s11786-018-0364-2">minimal height companion matrices</a> (see also <a class="reference external" href="https://journals.uwyo.edu/index.php/ela/article/view/1781">our first paper</a>); we do not have an algorithm for finding one for a given integer polynomial, for instance. We <em>believe</em> that minimal height companion matrices are generally better-conditioned as far as their eigenvalues, but we have no proof.  Find a minimal height companion matrix for (say) <span class="math notranslate nohighlight">\(\lambda^3 + 5\lambda^2 + 3\lambda + 1\)</span>.  Find a general algorithm for computing minimal height companions.  Prove that they’re useful.  If you succeed at this problem, you should certainly publish your results; a good venue might be the <a class="reference external" href="https://journals.uwyo.edu/index.php/ela">Electronic Journal of Linear Algebra</a>. <a class="reference internal" href="../Solutions/Reports%20on%20Mandelbrot%20Activities.html#mandelbrotactivityreport-15"><span class="std std-ref">[Our thoughts]</span></a></p>
<p id="mandelbrotactivity-16">16. Take some time and write down some of your own questions about this material.  As you can see, there is lots left to discover, here. <a class="reference internal" href="../Solutions/Reports%20on%20Mandelbrot%20Activities.html#mandelbrotactivityreport-16"><span class="std std-ref">[Our thoughts]</span></a></p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./Contents"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="bohemian-matrices.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Bounded Height Matrices of Integers (Bohemian Matrices)</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="chaos-game-representation.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Chaos Game Representation</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Neil J. Calkin, Eunice Y.S. Chan, and Robert M. Corless<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>